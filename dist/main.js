/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@fast-csv/format/build/src/CsvFormatterStream.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@fast-csv/format/build/src/CsvFormatterStream.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CsvFormatterStream = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst formatter_1 = __webpack_require__(/*! ./formatter */ \"./node_modules/@fast-csv/format/build/src/formatter/index.js\");\nclass CsvFormatterStream extends stream_1.Transform {\n    formatterOptions;\n    rowFormatter;\n    hasWrittenBOM = false;\n    constructor(formatterOptions) {\n        super({ writableObjectMode: formatterOptions.objectMode });\n        this.formatterOptions = formatterOptions;\n        this.rowFormatter = new formatter_1.RowFormatter(formatterOptions);\n        // if writeBOM is false then set to true\n        // if writeBOM is true then set to false by default so it is written out\n        this.hasWrittenBOM = !formatterOptions.writeBOM;\n    }\n    transform(transformFunction) {\n        this.rowFormatter.rowTransform = transformFunction;\n        return this;\n    }\n    _transform(row, encoding, cb) {\n        let cbCalled = false;\n        try {\n            if (!this.hasWrittenBOM) {\n                this.push(this.formatterOptions.BOM);\n                this.hasWrittenBOM = true;\n            }\n            this.rowFormatter.format(row, (err, rows) => {\n                if (err) {\n                    cbCalled = true;\n                    return cb(err);\n                }\n                if (rows) {\n                    rows.forEach((r) => {\n                        this.push(Buffer.from(r, 'utf8'));\n                    });\n                }\n                cbCalled = true;\n                return cb();\n            });\n        }\n        catch (e) {\n            if (cbCalled) {\n                throw e;\n            }\n            cb(e);\n        }\n    }\n    _flush(cb) {\n        this.rowFormatter.finish((err, rows) => {\n            if (err) {\n                return cb(err);\n            }\n            if (rows) {\n                rows.forEach((r) => {\n                    this.push(Buffer.from(r, 'utf8'));\n                });\n            }\n            return cb();\n        });\n    }\n}\nexports.CsvFormatterStream = CsvFormatterStream;\n//# sourceMappingURL=CsvFormatterStream.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/format/build/src/CsvFormatterStream.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/format/build/src/FormatterOptions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@fast-csv/format/build/src/FormatterOptions.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FormatterOptions = void 0;\nclass FormatterOptions {\n    objectMode = true;\n    delimiter = ',';\n    rowDelimiter = '\\n';\n    quote = '\"';\n    escape = this.quote;\n    quoteColumns = false;\n    quoteHeaders = this.quoteColumns;\n    headers = null;\n    includeEndRowDelimiter = false;\n    transform;\n    shouldWriteHeaders;\n    writeBOM = false;\n    escapedQuote;\n    BOM = '\\ufeff';\n    alwaysWriteHeaders = false;\n    constructor(opts = {}) {\n        Object.assign(this, opts || {});\n        if (typeof opts?.quoteHeaders === 'undefined') {\n            this.quoteHeaders = this.quoteColumns;\n        }\n        if (opts?.quote === true) {\n            this.quote = '\"';\n        }\n        else if (opts?.quote === false) {\n            this.quote = '';\n        }\n        if (typeof opts?.escape !== 'string') {\n            this.escape = this.quote;\n        }\n        this.shouldWriteHeaders = !!this.headers && (opts.writeHeaders ?? true);\n        this.headers = Array.isArray(this.headers) ? this.headers : null;\n        this.escapedQuote = `${this.escape}${this.quote}`;\n    }\n}\nexports.FormatterOptions = FormatterOptions;\n//# sourceMappingURL=FormatterOptions.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/format/build/src/FormatterOptions.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/format/build/src/formatter/FieldFormatter.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@fast-csv/format/build/src/formatter/FieldFormatter.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FieldFormatter = void 0;\nconst lodash_isboolean_1 = __importDefault(__webpack_require__(/*! lodash.isboolean */ \"./node_modules/lodash.isboolean/index.js\"));\nconst lodash_isnil_1 = __importDefault(__webpack_require__(/*! lodash.isnil */ \"./node_modules/lodash.isnil/index.js\"));\nconst lodash_escaperegexp_1 = __importDefault(__webpack_require__(/*! lodash.escaperegexp */ \"./node_modules/lodash.escaperegexp/index.js\"));\nclass FieldFormatter {\n    formatterOptions;\n    _headers = null;\n    REPLACE_REGEXP;\n    ESCAPE_REGEXP;\n    constructor(formatterOptions) {\n        this.formatterOptions = formatterOptions;\n        if (formatterOptions.headers !== null) {\n            this.headers = formatterOptions.headers;\n        }\n        this.REPLACE_REGEXP = new RegExp(formatterOptions.quote, 'g');\n        const escapePattern = `[${formatterOptions.delimiter}${(0, lodash_escaperegexp_1.default)(formatterOptions.rowDelimiter)}|\\r|\\n]`;\n        this.ESCAPE_REGEXP = new RegExp(escapePattern);\n    }\n    set headers(headers) {\n        this._headers = headers;\n    }\n    shouldQuote(fieldIndex, isHeader) {\n        const quoteConfig = isHeader ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;\n        if ((0, lodash_isboolean_1.default)(quoteConfig)) {\n            return quoteConfig;\n        }\n        if (Array.isArray(quoteConfig)) {\n            return quoteConfig[fieldIndex];\n        }\n        if (this._headers !== null) {\n            return quoteConfig[this._headers[fieldIndex]];\n        }\n        return false;\n    }\n    format(field, fieldIndex, isHeader) {\n        const preparedField = `${(0, lodash_isnil_1.default)(field) ? '' : field}`.replace(/\\0/g, '');\n        const { formatterOptions } = this;\n        if (formatterOptions.quote !== '') {\n            const shouldEscape = preparedField.indexOf(formatterOptions.quote) !== -1;\n            if (shouldEscape) {\n                return this.quoteField(preparedField.replace(this.REPLACE_REGEXP, formatterOptions.escapedQuote));\n            }\n        }\n        const hasEscapeCharacters = preparedField.search(this.ESCAPE_REGEXP) !== -1;\n        if (hasEscapeCharacters || this.shouldQuote(fieldIndex, isHeader)) {\n            return this.quoteField(preparedField);\n        }\n        return preparedField;\n    }\n    quoteField(field) {\n        const { quote } = this.formatterOptions;\n        return `${quote}${field}${quote}`;\n    }\n}\nexports.FieldFormatter = FieldFormatter;\n//# sourceMappingURL=FieldFormatter.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/format/build/src/formatter/FieldFormatter.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/format/build/src/formatter/RowFormatter.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@fast-csv/format/build/src/formatter/RowFormatter.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RowFormatter = void 0;\nconst lodash_isfunction_1 = __importDefault(__webpack_require__(/*! lodash.isfunction */ \"./node_modules/lodash.isfunction/index.js\"));\nconst lodash_isequal_1 = __importDefault(__webpack_require__(/*! lodash.isequal */ \"./node_modules/lodash.isequal/index.js\"));\nconst FieldFormatter_1 = __webpack_require__(/*! ./FieldFormatter */ \"./node_modules/@fast-csv/format/build/src/formatter/FieldFormatter.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/@fast-csv/format/build/src/types.js\");\nclass RowFormatter {\n    static isRowHashArray(row) {\n        if (Array.isArray(row)) {\n            return Array.isArray(row[0]) && row[0].length === 2;\n        }\n        return false;\n    }\n    static isRowArray(row) {\n        return Array.isArray(row) && !this.isRowHashArray(row);\n    }\n    // get headers from a row item\n    static gatherHeaders(row) {\n        if (RowFormatter.isRowHashArray(row)) {\n            // lets assume a multi-dimesional array with item 0 being the header\n            return row.map((it) => {\n                return it[0];\n            });\n        }\n        if (Array.isArray(row)) {\n            return row;\n        }\n        return Object.keys(row);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    static createTransform(transformFunction) {\n        if ((0, types_1.isSyncTransform)(transformFunction)) {\n            return (row, cb) => {\n                let transformedRow = null;\n                try {\n                    transformedRow = transformFunction(row);\n                }\n                catch (e) {\n                    return cb(e);\n                }\n                return cb(null, transformedRow);\n            };\n        }\n        return (row, cb) => {\n            transformFunction(row, cb);\n        };\n    }\n    formatterOptions;\n    fieldFormatter;\n    shouldWriteHeaders;\n    _rowTransform;\n    headers;\n    hasWrittenHeaders;\n    rowCount = 0;\n    constructor(formatterOptions) {\n        this.formatterOptions = formatterOptions;\n        this.fieldFormatter = new FieldFormatter_1.FieldFormatter(formatterOptions);\n        this.headers = formatterOptions.headers;\n        this.shouldWriteHeaders = formatterOptions.shouldWriteHeaders;\n        this.hasWrittenHeaders = false;\n        if (this.headers !== null) {\n            this.fieldFormatter.headers = this.headers;\n        }\n        if (formatterOptions.transform) {\n            this.rowTransform = formatterOptions.transform;\n        }\n    }\n    set rowTransform(transformFunction) {\n        if (!(0, lodash_isfunction_1.default)(transformFunction)) {\n            throw new TypeError('The transform should be a function');\n        }\n        this._rowTransform = RowFormatter.createTransform(transformFunction);\n    }\n    format(row, cb) {\n        this.callTransformer(row, (err, transformedRow) => {\n            if (err) {\n                return cb(err);\n            }\n            if (!row) {\n                return cb(null);\n            }\n            const rows = [];\n            if (transformedRow) {\n                const { shouldFormatColumns, headers } = this.checkHeaders(transformedRow);\n                if (this.shouldWriteHeaders && headers && !this.hasWrittenHeaders) {\n                    rows.push(this.formatColumns(headers, true));\n                    this.hasWrittenHeaders = true;\n                }\n                if (shouldFormatColumns) {\n                    const columns = this.gatherColumns(transformedRow);\n                    rows.push(this.formatColumns(columns, false));\n                }\n            }\n            return cb(null, rows);\n        });\n    }\n    finish(cb) {\n        const rows = [];\n        // check if we should write headers and we didnt get any rows\n        if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {\n            if (!this.headers) {\n                return cb(new Error('`alwaysWriteHeaders` option is set to true but `headers` option not provided.'));\n            }\n            rows.push(this.formatColumns(this.headers, true));\n        }\n        if (this.formatterOptions.includeEndRowDelimiter) {\n            rows.push(this.formatterOptions.rowDelimiter);\n        }\n        return cb(null, rows);\n    }\n    // check if we need to write header return true if we should also write a row\n    // could be false if headers is true and the header row(first item) is passed in\n    checkHeaders(row) {\n        if (this.headers) {\n            // either the headers were provided by the user or we have already gathered them.\n            return { shouldFormatColumns: true, headers: this.headers };\n        }\n        const headers = RowFormatter.gatherHeaders(row);\n        this.headers = headers;\n        this.fieldFormatter.headers = headers;\n        if (!this.shouldWriteHeaders) {\n            // if we are not supposed to write the headers then\n            // always format the columns\n            return { shouldFormatColumns: true, headers: null };\n        }\n        // if the row is equal to headers dont format\n        return { shouldFormatColumns: !(0, lodash_isequal_1.default)(headers, row), headers };\n    }\n    // todo change this method to unknown[]\n    gatherColumns(row) {\n        if (this.headers === null) {\n            throw new Error('Headers is currently null');\n        }\n        if (!Array.isArray(row)) {\n            return this.headers.map((header) => {\n                return row[header];\n            });\n        }\n        if (RowFormatter.isRowHashArray(row)) {\n            return this.headers.map((header, i) => {\n                const col = row[i];\n                if (col) {\n                    return col[1];\n                }\n                return '';\n            });\n        }\n        // if its a one dimensional array and headers were not provided\n        // then just return the row\n        if (RowFormatter.isRowArray(row) && !this.shouldWriteHeaders) {\n            return row;\n        }\n        return this.headers.map((header, i) => {\n            return row[i];\n        });\n    }\n    callTransformer(row, cb) {\n        if (!this._rowTransform) {\n            return cb(null, row);\n        }\n        return this._rowTransform(row, cb);\n    }\n    formatColumns(columns, isHeadersRow) {\n        const formattedCols = columns\n            .map((field, i) => {\n            return this.fieldFormatter.format(field, i, isHeadersRow);\n        })\n            .join(this.formatterOptions.delimiter);\n        const { rowCount } = this;\n        this.rowCount += 1;\n        if (rowCount) {\n            return [this.formatterOptions.rowDelimiter, formattedCols].join('');\n        }\n        return formattedCols;\n    }\n}\nexports.RowFormatter = RowFormatter;\n//# sourceMappingURL=RowFormatter.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/format/build/src/formatter/RowFormatter.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/format/build/src/formatter/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@fast-csv/format/build/src/formatter/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FieldFormatter = exports.RowFormatter = void 0;\nvar RowFormatter_1 = __webpack_require__(/*! ./RowFormatter */ \"./node_modules/@fast-csv/format/build/src/formatter/RowFormatter.js\");\nObject.defineProperty(exports, \"RowFormatter\", ({ enumerable: true, get: function () { return RowFormatter_1.RowFormatter; } }));\nvar FieldFormatter_1 = __webpack_require__(/*! ./FieldFormatter */ \"./node_modules/@fast-csv/format/build/src/formatter/FieldFormatter.js\");\nObject.defineProperty(exports, \"FieldFormatter\", ({ enumerable: true, get: function () { return FieldFormatter_1.FieldFormatter; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/format/build/src/formatter/index.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/format/build/src/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@fast-csv/format/build/src/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.writeToPath = exports.writeToString = exports.writeToBuffer = exports.writeToStream = exports.write = exports.format = exports.FormatterOptions = exports.CsvFormatterStream = void 0;\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst FormatterOptions_1 = __webpack_require__(/*! ./FormatterOptions */ \"./node_modules/@fast-csv/format/build/src/FormatterOptions.js\");\nconst CsvFormatterStream_1 = __webpack_require__(/*! ./CsvFormatterStream */ \"./node_modules/@fast-csv/format/build/src/CsvFormatterStream.js\");\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/@fast-csv/format/build/src/types.js\"), exports);\nvar CsvFormatterStream_2 = __webpack_require__(/*! ./CsvFormatterStream */ \"./node_modules/@fast-csv/format/build/src/CsvFormatterStream.js\");\nObject.defineProperty(exports, \"CsvFormatterStream\", ({ enumerable: true, get: function () { return CsvFormatterStream_2.CsvFormatterStream; } }));\nvar FormatterOptions_2 = __webpack_require__(/*! ./FormatterOptions */ \"./node_modules/@fast-csv/format/build/src/FormatterOptions.js\");\nObject.defineProperty(exports, \"FormatterOptions\", ({ enumerable: true, get: function () { return FormatterOptions_2.FormatterOptions; } }));\nconst format = (options) => {\n    return new CsvFormatterStream_1.CsvFormatterStream(new FormatterOptions_1.FormatterOptions(options));\n};\nexports.format = format;\nconst write = (rows, options) => {\n    const csvStream = (0, exports.format)(options);\n    const promiseWrite = (0, util_1.promisify)((row, cb) => {\n        csvStream.write(row, undefined, cb);\n    });\n    rows.reduce((prev, row) => {\n        return prev.then(() => {\n            return promiseWrite(row);\n        });\n    }, Promise.resolve())\n        .then(() => {\n        csvStream.end();\n    })\n        .catch((err) => {\n        csvStream.emit('error', err);\n    });\n    return csvStream;\n};\nexports.write = write;\nconst writeToStream = (ws, rows, options) => {\n    return (0, exports.write)(rows, options).pipe(ws);\n};\nexports.writeToStream = writeToStream;\nconst writeToBuffer = (rows, opts = {}) => {\n    const buffers = [];\n    const ws = new stream_1.Writable({\n        write(data, enc, writeCb) {\n            buffers.push(data);\n            writeCb();\n        },\n    });\n    return new Promise((res, rej) => {\n        ws.on('error', rej).on('finish', () => {\n            return res(Buffer.concat(buffers));\n        });\n        (0, exports.write)(rows, opts).pipe(ws);\n    });\n};\nexports.writeToBuffer = writeToBuffer;\nconst writeToString = (rows, options) => {\n    return (0, exports.writeToBuffer)(rows, options).then((buffer) => {\n        return buffer.toString();\n    });\n};\nexports.writeToString = writeToString;\nconst writeToPath = (path, rows, options) => {\n    const stream = fs.createWriteStream(path, { encoding: 'utf8' });\n    return (0, exports.write)(rows, options).pipe(stream);\n};\nexports.writeToPath = writeToPath;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/format/build/src/index.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/format/build/src/types.js":
/*!**********************************************************!*\
  !*** ./node_modules/@fast-csv/format/build/src/types.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSyncTransform = void 0;\nconst isSyncTransform = (transform) => {\n    return transform.length === 1;\n};\nexports.isSyncTransform = isSyncTransform;\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/format/build/src/types.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/CsvParserStream.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/CsvParserStream.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CsvParserStream = void 0;\nconst string_decoder_1 = __webpack_require__(/*! string_decoder */ \"string_decoder\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst transforms_1 = __webpack_require__(/*! ./transforms */ \"./node_modules/@fast-csv/parse/build/src/transforms/index.js\");\nconst parser_1 = __webpack_require__(/*! ./parser */ \"./node_modules/@fast-csv/parse/build/src/parser/index.js\");\nclass CsvParserStream extends stream_1.Transform {\n    parserOptions;\n    decoder;\n    parser;\n    headerTransformer;\n    rowTransformerValidator;\n    lines = '';\n    rowCount = 0;\n    parsedRowCount = 0;\n    parsedLineCount = 0;\n    endEmitted = false;\n    headersEmitted = false;\n    constructor(parserOptions) {\n        super({ objectMode: parserOptions.objectMode });\n        this.parserOptions = parserOptions;\n        this.parser = new parser_1.Parser(parserOptions);\n        this.headerTransformer = new transforms_1.HeaderTransformer(parserOptions);\n        this.decoder = new string_decoder_1.StringDecoder(parserOptions.encoding);\n        this.rowTransformerValidator = new transforms_1.RowTransformerValidator();\n    }\n    get hasHitRowLimit() {\n        return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;\n    }\n    get shouldEmitRows() {\n        return this.parsedRowCount > this.parserOptions.skipRows;\n    }\n    get shouldSkipLine() {\n        return this.parsedLineCount <= this.parserOptions.skipLines;\n    }\n    transform(transformFunction) {\n        this.rowTransformerValidator.rowTransform = transformFunction;\n        return this;\n    }\n    validate(validateFunction) {\n        this.rowTransformerValidator.rowValidator = validateFunction;\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    emit(event, ...rest) {\n        if (event === 'end') {\n            if (!this.endEmitted) {\n                this.endEmitted = true;\n                super.emit('end', this.rowCount);\n            }\n            return false;\n        }\n        return super.emit(event, ...rest);\n    }\n    _transform(data, encoding, done) {\n        // if we have hit our maxRows parsing limit then skip parsing\n        if (this.hasHitRowLimit) {\n            return done();\n        }\n        const wrappedCallback = CsvParserStream.wrapDoneCallback(done);\n        try {\n            const { lines } = this;\n            const newLine = lines + this.decoder.write(data);\n            const rows = this.parse(newLine, true);\n            return this.processRows(rows, wrappedCallback);\n        }\n        catch (e) {\n            return wrappedCallback(e);\n        }\n    }\n    _flush(done) {\n        const wrappedCallback = CsvParserStream.wrapDoneCallback(done);\n        // if we have hit our maxRows parsing limit then skip parsing\n        if (this.hasHitRowLimit) {\n            return wrappedCallback();\n        }\n        try {\n            const newLine = this.lines + this.decoder.end();\n            const rows = this.parse(newLine, false);\n            return this.processRows(rows, wrappedCallback);\n        }\n        catch (e) {\n            return wrappedCallback(e);\n        }\n    }\n    parse(data, hasMoreData) {\n        if (!data) {\n            return [];\n        }\n        const { line, rows } = this.parser.parse(data, hasMoreData);\n        this.lines = line;\n        return rows;\n    }\n    processRows(rows, cb) {\n        const rowsLength = rows.length;\n        const iterate = (i) => {\n            const callNext = (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (i % 100 === 0) {\n                    // incase the transform are sync insert a next tick to prevent stack overflow\n                    setImmediate(() => {\n                        return iterate(i + 1);\n                    });\n                    return undefined;\n                }\n                return iterate(i + 1);\n            };\n            this.checkAndEmitHeaders();\n            // if we have emitted all rows or we have hit the maxRows limit option\n            // then end\n            if (i >= rowsLength || this.hasHitRowLimit) {\n                return cb();\n            }\n            this.parsedLineCount += 1;\n            if (this.shouldSkipLine) {\n                return callNext();\n            }\n            const row = rows[i];\n            this.rowCount += 1;\n            this.parsedRowCount += 1;\n            const nextRowCount = this.rowCount;\n            return this.transformRow(row, (err, transformResult) => {\n                if (err) {\n                    this.rowCount -= 1;\n                    return callNext(err);\n                }\n                if (!transformResult) {\n                    return callNext(new Error('expected transform result'));\n                }\n                if (!transformResult.isValid) {\n                    this.emit('data-invalid', transformResult.row, nextRowCount, transformResult.reason);\n                }\n                else if (transformResult.row) {\n                    return this.pushRow(transformResult.row, callNext);\n                }\n                return callNext();\n            });\n        };\n        iterate(0);\n    }\n    transformRow(parsedRow, cb) {\n        try {\n            this.headerTransformer.transform(parsedRow, (err, withHeaders) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (!withHeaders) {\n                    return cb(new Error('Expected result from header transform'));\n                }\n                if (!withHeaders.isValid) {\n                    if (this.shouldEmitRows) {\n                        return cb(null, { isValid: false, row: parsedRow });\n                    }\n                    // skipped because of skipRows option remove from total row count\n                    return this.skipRow(cb);\n                }\n                if (withHeaders.row) {\n                    if (this.shouldEmitRows) {\n                        return this.rowTransformerValidator.transformAndValidate(withHeaders.row, cb);\n                    }\n                    // skipped because of skipRows option remove from total row count\n                    return this.skipRow(cb);\n                }\n                // this is a header row dont include in the rowCount or parsedRowCount\n                this.rowCount -= 1;\n                this.parsedRowCount -= 1;\n                return cb(null, { row: null, isValid: true });\n            });\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    checkAndEmitHeaders() {\n        if (!this.headersEmitted && this.headerTransformer.headers) {\n            this.headersEmitted = true;\n            this.emit('headers', this.headerTransformer.headers);\n        }\n    }\n    skipRow(cb) {\n        // skipped because of skipRows option remove from total row count\n        this.rowCount -= 1;\n        return cb(null, { row: null, isValid: true });\n    }\n    pushRow(row, cb) {\n        try {\n            if (!this.parserOptions.objectMode) {\n                this.push(JSON.stringify(row));\n            }\n            else {\n                this.push(row);\n            }\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    static wrapDoneCallback(done) {\n        let errorCalled = false;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (err, ...args) => {\n            if (err) {\n                if (errorCalled) {\n                    throw err;\n                }\n                errorCalled = true;\n                done(err);\n                return;\n            }\n            done(...args);\n        };\n    }\n}\nexports.CsvParserStream = CsvParserStream;\n//# sourceMappingURL=CsvParserStream.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/CsvParserStream.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/ParserOptions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/ParserOptions.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParserOptions = void 0;\nconst lodash_escaperegexp_1 = __importDefault(__webpack_require__(/*! lodash.escaperegexp */ \"./node_modules/lodash.escaperegexp/index.js\"));\nconst lodash_isnil_1 = __importDefault(__webpack_require__(/*! lodash.isnil */ \"./node_modules/lodash.isnil/index.js\"));\nclass ParserOptions {\n    escapedDelimiter;\n    objectMode = true;\n    delimiter = ',';\n    ignoreEmpty = false;\n    quote = '\"';\n    escape = null;\n    escapeChar = this.quote;\n    comment = null;\n    supportsComments = false;\n    ltrim = false;\n    rtrim = false;\n    trim = false;\n    headers = null;\n    renameHeaders = false;\n    strictColumnHandling = false;\n    discardUnmappedColumns = false;\n    carriageReturn = '\\r';\n    NEXT_TOKEN_REGEXP;\n    encoding = 'utf8';\n    limitRows = false;\n    maxRows = 0;\n    skipLines = 0;\n    skipRows = 0;\n    constructor(opts) {\n        Object.assign(this, opts || {});\n        if (this.delimiter.length > 1) {\n            throw new Error('delimiter option must be one character long');\n        }\n        this.escapedDelimiter = (0, lodash_escaperegexp_1.default)(this.delimiter);\n        this.escapeChar = this.escape ?? this.quote;\n        this.supportsComments = !(0, lodash_isnil_1.default)(this.comment);\n        this.NEXT_TOKEN_REGEXP = new RegExp(`([^\\\\s]|\\\\r\\\\n|\\\\n|\\\\r|${this.escapedDelimiter})`);\n        if (this.maxRows > 0) {\n            this.limitRows = true;\n        }\n    }\n}\nexports.ParserOptions = ParserOptions;\n//# sourceMappingURL=ParserOptions.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/ParserOptions.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseString = exports.parseFile = exports.parseStream = exports.parse = exports.ParserOptions = exports.CsvParserStream = void 0;\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst ParserOptions_1 = __webpack_require__(/*! ./ParserOptions */ \"./node_modules/@fast-csv/parse/build/src/ParserOptions.js\");\nconst CsvParserStream_1 = __webpack_require__(/*! ./CsvParserStream */ \"./node_modules/@fast-csv/parse/build/src/CsvParserStream.js\");\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/@fast-csv/parse/build/src/types.js\"), exports);\nvar CsvParserStream_2 = __webpack_require__(/*! ./CsvParserStream */ \"./node_modules/@fast-csv/parse/build/src/CsvParserStream.js\");\nObject.defineProperty(exports, \"CsvParserStream\", ({ enumerable: true, get: function () { return CsvParserStream_2.CsvParserStream; } }));\nvar ParserOptions_2 = __webpack_require__(/*! ./ParserOptions */ \"./node_modules/@fast-csv/parse/build/src/ParserOptions.js\");\nObject.defineProperty(exports, \"ParserOptions\", ({ enumerable: true, get: function () { return ParserOptions_2.ParserOptions; } }));\nconst parse = (args) => {\n    return new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(args));\n};\nexports.parse = parse;\nconst parseStream = (stream, options) => {\n    return stream.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));\n};\nexports.parseStream = parseStream;\nconst parseFile = (location, options = {}) => {\n    return fs.createReadStream(location).pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));\n};\nexports.parseFile = parseFile;\nconst parseString = (string, options) => {\n    const rs = new stream_1.Readable();\n    rs.push(string);\n    rs.push(null);\n    return rs.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));\n};\nexports.parseString = parseString;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/index.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/parser/Parser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/parser/Parser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = void 0;\nconst Scanner_1 = __webpack_require__(/*! ./Scanner */ \"./node_modules/@fast-csv/parse/build/src/parser/Scanner.js\");\nconst RowParser_1 = __webpack_require__(/*! ./RowParser */ \"./node_modules/@fast-csv/parse/build/src/parser/RowParser.js\");\nconst Token_1 = __webpack_require__(/*! ./Token */ \"./node_modules/@fast-csv/parse/build/src/parser/Token.js\");\nclass Parser {\n    static removeBOM(line) {\n        // Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n        // conversion translates it to FEFF (UTF-16 BOM)\n        if (line && line.charCodeAt(0) === 0xfeff) {\n            return line.slice(1);\n        }\n        return line;\n    }\n    parserOptions;\n    rowParser;\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.rowParser = new RowParser_1.RowParser(this.parserOptions);\n    }\n    parse(line, hasMoreData) {\n        const scanner = new Scanner_1.Scanner({\n            line: Parser.removeBOM(line),\n            parserOptions: this.parserOptions,\n            hasMoreData,\n        });\n        if (this.parserOptions.supportsComments) {\n            return this.parseWithComments(scanner);\n        }\n        return this.parseWithoutComments(scanner);\n    }\n    parseWithoutComments(scanner) {\n        const rows = [];\n        let shouldContinue = true;\n        while (shouldContinue) {\n            shouldContinue = this.parseRow(scanner, rows);\n        }\n        return { line: scanner.line, rows };\n    }\n    parseWithComments(scanner) {\n        const { parserOptions } = this;\n        const rows = [];\n        for (let nextToken = scanner.nextCharacterToken; nextToken !== null; nextToken = scanner.nextCharacterToken) {\n            if (Token_1.Token.isTokenComment(nextToken, parserOptions)) {\n                const cursor = scanner.advancePastLine();\n                if (cursor === null) {\n                    return { line: scanner.lineFromCursor, rows };\n                }\n                if (!scanner.hasMoreCharacters) {\n                    return { line: scanner.lineFromCursor, rows };\n                }\n                scanner.truncateToCursor();\n            }\n            else if (!this.parseRow(scanner, rows)) {\n                break;\n            }\n        }\n        return { line: scanner.line, rows };\n    }\n    parseRow(scanner, rows) {\n        const nextToken = scanner.nextNonSpaceToken;\n        if (!nextToken) {\n            return false;\n        }\n        const row = this.rowParser.parse(scanner);\n        if (row === null) {\n            return false;\n        }\n        if (this.parserOptions.ignoreEmpty && RowParser_1.RowParser.isEmptyRow(row)) {\n            return true;\n        }\n        rows.push(row);\n        return true;\n    }\n}\nexports.Parser = Parser;\n//# sourceMappingURL=Parser.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/parser/Parser.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/parser/RowParser.js":
/*!********************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/parser/RowParser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RowParser = void 0;\nconst column_1 = __webpack_require__(/*! ./column */ \"./node_modules/@fast-csv/parse/build/src/parser/column/index.js\");\nconst Token_1 = __webpack_require__(/*! ./Token */ \"./node_modules/@fast-csv/parse/build/src/parser/Token.js\");\nconst EMPTY_STRING = '';\nclass RowParser {\n    static isEmptyRow(row) {\n        return row.join(EMPTY_STRING).replace(/\\s+/g, EMPTY_STRING) === EMPTY_STRING;\n    }\n    parserOptions;\n    columnParser;\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.columnParser = new column_1.ColumnParser(parserOptions);\n    }\n    parse(scanner) {\n        const { parserOptions } = this;\n        const { hasMoreData } = scanner;\n        const currentScanner = scanner;\n        const columns = [];\n        let currentToken = this.getStartToken(currentScanner, columns);\n        while (currentToken) {\n            if (Token_1.Token.isTokenRowDelimiter(currentToken)) {\n                currentScanner.advancePastToken(currentToken);\n                // if ends with CR and there is more data, keep unparsed due to possible\n                // coming LF in CRLF\n                if (!currentScanner.hasMoreCharacters &&\n                    Token_1.Token.isTokenCarriageReturn(currentToken, parserOptions) &&\n                    hasMoreData) {\n                    return null;\n                }\n                currentScanner.truncateToCursor();\n                return columns;\n            }\n            if (!this.shouldSkipColumnParse(currentScanner, currentToken, columns)) {\n                const item = this.columnParser.parse(currentScanner);\n                if (item === null) {\n                    return null;\n                }\n                columns.push(item);\n            }\n            currentToken = currentScanner.nextNonSpaceToken;\n        }\n        if (!hasMoreData) {\n            currentScanner.truncateToCursor();\n            return columns;\n        }\n        return null;\n    }\n    getStartToken(scanner, columns) {\n        const currentToken = scanner.nextNonSpaceToken;\n        if (currentToken !== null && Token_1.Token.isTokenDelimiter(currentToken, this.parserOptions)) {\n            columns.push('');\n            return scanner.nextNonSpaceToken;\n        }\n        return currentToken;\n    }\n    shouldSkipColumnParse(scanner, currentToken, columns) {\n        const { parserOptions } = this;\n        if (Token_1.Token.isTokenDelimiter(currentToken, parserOptions)) {\n            scanner.advancePastToken(currentToken);\n            // if the delimiter is at the end of a line\n            const nextToken = scanner.nextCharacterToken;\n            if (!scanner.hasMoreCharacters || (nextToken !== null && Token_1.Token.isTokenRowDelimiter(nextToken))) {\n                columns.push('');\n                return true;\n            }\n            if (nextToken !== null && Token_1.Token.isTokenDelimiter(nextToken, parserOptions)) {\n                columns.push('');\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.RowParser = RowParser;\n//# sourceMappingURL=RowParser.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/parser/RowParser.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/parser/Scanner.js":
/*!******************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/parser/Scanner.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scanner = void 0;\nconst Token_1 = __webpack_require__(/*! ./Token */ \"./node_modules/@fast-csv/parse/build/src/parser/Token.js\");\nconst ROW_DELIMITER = /((?:\\r\\n)|\\n|\\r)/;\nclass Scanner {\n    line;\n    parserOptions;\n    lineLength;\n    hasMoreData;\n    cursor = 0;\n    constructor(args) {\n        this.line = args.line;\n        this.lineLength = this.line.length;\n        this.parserOptions = args.parserOptions;\n        this.hasMoreData = args.hasMoreData;\n        this.cursor = args.cursor || 0;\n    }\n    get hasMoreCharacters() {\n        return this.lineLength > this.cursor;\n    }\n    get nextNonSpaceToken() {\n        const { lineFromCursor } = this;\n        const regex = this.parserOptions.NEXT_TOKEN_REGEXP;\n        if (lineFromCursor.search(regex) === -1) {\n            return null;\n        }\n        const match = regex.exec(lineFromCursor);\n        if (match == null) {\n            return null;\n        }\n        const token = match[1];\n        const startCursor = this.cursor + (match.index || 0);\n        return new Token_1.Token({\n            token,\n            startCursor,\n            endCursor: startCursor + token.length - 1,\n        });\n    }\n    get nextCharacterToken() {\n        const { cursor, lineLength } = this;\n        if (lineLength <= cursor) {\n            return null;\n        }\n        return new Token_1.Token({\n            token: this.line[cursor],\n            startCursor: cursor,\n            endCursor: cursor,\n        });\n    }\n    get lineFromCursor() {\n        return this.line.substr(this.cursor);\n    }\n    advancePastLine() {\n        const match = ROW_DELIMITER.exec(this.lineFromCursor);\n        if (!match) {\n            if (this.hasMoreData) {\n                return null;\n            }\n            this.cursor = this.lineLength;\n            return this;\n        }\n        this.cursor += (match.index || 0) + match[0].length;\n        return this;\n    }\n    advanceTo(cursor) {\n        this.cursor = cursor;\n        return this;\n    }\n    advanceToToken(token) {\n        this.cursor = token.startCursor;\n        return this;\n    }\n    advancePastToken(token) {\n        this.cursor = token.endCursor + 1;\n        return this;\n    }\n    truncateToCursor() {\n        this.line = this.lineFromCursor;\n        this.lineLength = this.line.length;\n        this.cursor = 0;\n        return this;\n    }\n}\nexports.Scanner = Scanner;\n//# sourceMappingURL=Scanner.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/parser/Scanner.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/parser/Token.js":
/*!****************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/parser/Token.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Token = void 0;\nclass Token {\n    static isTokenRowDelimiter(token) {\n        const content = token.token;\n        return content === '\\r' || content === '\\n' || content === '\\r\\n';\n    }\n    static isTokenCarriageReturn(token, parserOptions) {\n        return token.token === parserOptions.carriageReturn;\n    }\n    static isTokenComment(token, parserOptions) {\n        return parserOptions.supportsComments && !!token && token.token === parserOptions.comment;\n    }\n    static isTokenEscapeCharacter(token, parserOptions) {\n        return token.token === parserOptions.escapeChar;\n    }\n    static isTokenQuote(token, parserOptions) {\n        return token.token === parserOptions.quote;\n    }\n    static isTokenDelimiter(token, parserOptions) {\n        return token.token === parserOptions.delimiter;\n    }\n    token;\n    startCursor;\n    endCursor;\n    constructor(tokenArgs) {\n        this.token = tokenArgs.token;\n        this.startCursor = tokenArgs.startCursor;\n        this.endCursor = tokenArgs.endCursor;\n    }\n}\nexports.Token = Token;\n//# sourceMappingURL=Token.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/parser/Token.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/parser/column/ColumnFormatter.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/parser/column/ColumnFormatter.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ColumnFormatter = void 0;\nclass ColumnFormatter {\n    format;\n    constructor(parserOptions) {\n        if (parserOptions.trim) {\n            this.format = (col) => {\n                return col.trim();\n            };\n        }\n        else if (parserOptions.ltrim) {\n            this.format = (col) => {\n                return col.trimLeft();\n            };\n        }\n        else if (parserOptions.rtrim) {\n            this.format = (col) => {\n                return col.trimRight();\n            };\n        }\n        else {\n            this.format = (col) => {\n                return col;\n            };\n        }\n    }\n}\nexports.ColumnFormatter = ColumnFormatter;\n//# sourceMappingURL=ColumnFormatter.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/parser/column/ColumnFormatter.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/parser/column/ColumnParser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/parser/column/ColumnParser.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ColumnParser = void 0;\nconst NonQuotedColumnParser_1 = __webpack_require__(/*! ./NonQuotedColumnParser */ \"./node_modules/@fast-csv/parse/build/src/parser/column/NonQuotedColumnParser.js\");\nconst QuotedColumnParser_1 = __webpack_require__(/*! ./QuotedColumnParser */ \"./node_modules/@fast-csv/parse/build/src/parser/column/QuotedColumnParser.js\");\nconst Token_1 = __webpack_require__(/*! ../Token */ \"./node_modules/@fast-csv/parse/build/src/parser/Token.js\");\nclass ColumnParser {\n    parserOptions;\n    nonQuotedColumnParser;\n    quotedColumnParser;\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.quotedColumnParser = new QuotedColumnParser_1.QuotedColumnParser(parserOptions);\n        this.nonQuotedColumnParser = new NonQuotedColumnParser_1.NonQuotedColumnParser(parserOptions);\n    }\n    parse(scanner) {\n        const { nextNonSpaceToken } = scanner;\n        if (nextNonSpaceToken !== null && Token_1.Token.isTokenQuote(nextNonSpaceToken, this.parserOptions)) {\n            scanner.advanceToToken(nextNonSpaceToken);\n            return this.quotedColumnParser.parse(scanner);\n        }\n        return this.nonQuotedColumnParser.parse(scanner);\n    }\n}\nexports.ColumnParser = ColumnParser;\n//# sourceMappingURL=ColumnParser.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/parser/column/ColumnParser.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/parser/column/NonQuotedColumnParser.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/parser/column/NonQuotedColumnParser.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NonQuotedColumnParser = void 0;\nconst ColumnFormatter_1 = __webpack_require__(/*! ./ColumnFormatter */ \"./node_modules/@fast-csv/parse/build/src/parser/column/ColumnFormatter.js\");\nconst Token_1 = __webpack_require__(/*! ../Token */ \"./node_modules/@fast-csv/parse/build/src/parser/Token.js\");\nclass NonQuotedColumnParser {\n    parserOptions;\n    columnFormatter;\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);\n    }\n    parse(scanner) {\n        if (!scanner.hasMoreCharacters) {\n            return null;\n        }\n        const { parserOptions } = this;\n        const characters = [];\n        let nextToken = scanner.nextCharacterToken;\n        for (; nextToken; nextToken = scanner.nextCharacterToken) {\n            if (Token_1.Token.isTokenDelimiter(nextToken, parserOptions) || Token_1.Token.isTokenRowDelimiter(nextToken)) {\n                break;\n            }\n            characters.push(nextToken.token);\n            scanner.advancePastToken(nextToken);\n        }\n        return this.columnFormatter.format(characters.join(''));\n    }\n}\nexports.NonQuotedColumnParser = NonQuotedColumnParser;\n//# sourceMappingURL=NonQuotedColumnParser.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/parser/column/NonQuotedColumnParser.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/parser/column/QuotedColumnParser.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/parser/column/QuotedColumnParser.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuotedColumnParser = void 0;\nconst ColumnFormatter_1 = __webpack_require__(/*! ./ColumnFormatter */ \"./node_modules/@fast-csv/parse/build/src/parser/column/ColumnFormatter.js\");\nconst Token_1 = __webpack_require__(/*! ../Token */ \"./node_modules/@fast-csv/parse/build/src/parser/Token.js\");\nclass QuotedColumnParser {\n    parserOptions;\n    columnFormatter;\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);\n    }\n    parse(scanner) {\n        if (!scanner.hasMoreCharacters) {\n            return null;\n        }\n        const originalCursor = scanner.cursor;\n        const { foundClosingQuote, col } = this.gatherDataBetweenQuotes(scanner);\n        if (!foundClosingQuote) {\n            // reset the cursor to the original\n            scanner.advanceTo(originalCursor);\n            // if we didnt find a closing quote but we potentially have more data then skip the parsing\n            // and return the original scanner.\n            if (!scanner.hasMoreData) {\n                throw new Error(`Parse Error: missing closing: '${this.parserOptions.quote || ''}' in line: at '${scanner.lineFromCursor.replace(/[\\r\\n]/g, \"\\\\n'\")}'`);\n            }\n            return null;\n        }\n        this.checkForMalformedColumn(scanner);\n        return col;\n    }\n    gatherDataBetweenQuotes(scanner) {\n        const { parserOptions } = this;\n        let foundStartingQuote = false;\n        let foundClosingQuote = false;\n        const characters = [];\n        let nextToken = scanner.nextCharacterToken;\n        for (; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken) {\n            const isQuote = Token_1.Token.isTokenQuote(nextToken, parserOptions);\n            // ignore first quote\n            if (!foundStartingQuote && isQuote) {\n                foundStartingQuote = true;\n            }\n            else if (foundStartingQuote) {\n                if (Token_1.Token.isTokenEscapeCharacter(nextToken, parserOptions)) {\n                    // advance past the escape character so we can get the next one in line\n                    scanner.advancePastToken(nextToken);\n                    const tokenFollowingEscape = scanner.nextCharacterToken;\n                    // if the character following the escape is a quote character then just add\n                    // the quote and advance to that character\n                    if (tokenFollowingEscape !== null &&\n                        (Token_1.Token.isTokenQuote(tokenFollowingEscape, parserOptions) ||\n                            Token_1.Token.isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {\n                        characters.push(tokenFollowingEscape.token);\n                        nextToken = tokenFollowingEscape;\n                    }\n                    else if (isQuote) {\n                        // if the escape is also a quote then we found our closing quote and finish early\n                        foundClosingQuote = true;\n                    }\n                    else {\n                        // other wise add the escape token to the characters since it wast escaping anything\n                        characters.push(nextToken.token);\n                    }\n                }\n                else if (isQuote) {\n                    // we found our closing quote!\n                    foundClosingQuote = true;\n                }\n                else {\n                    // add the token to the characters\n                    characters.push(nextToken.token);\n                }\n            }\n            scanner.advancePastToken(nextToken);\n        }\n        return { col: this.columnFormatter.format(characters.join('')), foundClosingQuote };\n    }\n    checkForMalformedColumn(scanner) {\n        const { parserOptions } = this;\n        const { nextNonSpaceToken } = scanner;\n        if (nextNonSpaceToken) {\n            const isNextTokenADelimiter = Token_1.Token.isTokenDelimiter(nextNonSpaceToken, parserOptions);\n            const isNextTokenARowDelimiter = Token_1.Token.isTokenRowDelimiter(nextNonSpaceToken);\n            if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {\n                // if the final quote was NOT followed by a column (,) or row(\\n) delimiter then its a bad column\n                // tldr: only part of the column was quoted\n                const linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\\r\\n]/g, \"\\\\n'\");\n                throw new Error(`Parse Error: expected: '${parserOptions.escapedDelimiter}' OR new line got: '${nextNonSpaceToken.token}'. at '${linePreview}'`);\n            }\n            scanner.advanceToToken(nextNonSpaceToken);\n        }\n        else if (!scanner.hasMoreData) {\n            scanner.advancePastLine();\n        }\n    }\n}\nexports.QuotedColumnParser = QuotedColumnParser;\n//# sourceMappingURL=QuotedColumnParser.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/parser/column/QuotedColumnParser.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/parser/column/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/parser/column/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ColumnFormatter = exports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = void 0;\nvar ColumnParser_1 = __webpack_require__(/*! ./ColumnParser */ \"./node_modules/@fast-csv/parse/build/src/parser/column/ColumnParser.js\");\nObject.defineProperty(exports, \"ColumnParser\", ({ enumerable: true, get: function () { return ColumnParser_1.ColumnParser; } }));\nvar NonQuotedColumnParser_1 = __webpack_require__(/*! ./NonQuotedColumnParser */ \"./node_modules/@fast-csv/parse/build/src/parser/column/NonQuotedColumnParser.js\");\nObject.defineProperty(exports, \"NonQuotedColumnParser\", ({ enumerable: true, get: function () { return NonQuotedColumnParser_1.NonQuotedColumnParser; } }));\nvar QuotedColumnParser_1 = __webpack_require__(/*! ./QuotedColumnParser */ \"./node_modules/@fast-csv/parse/build/src/parser/column/QuotedColumnParser.js\");\nObject.defineProperty(exports, \"QuotedColumnParser\", ({ enumerable: true, get: function () { return QuotedColumnParser_1.QuotedColumnParser; } }));\nvar ColumnFormatter_1 = __webpack_require__(/*! ./ColumnFormatter */ \"./node_modules/@fast-csv/parse/build/src/parser/column/ColumnFormatter.js\");\nObject.defineProperty(exports, \"ColumnFormatter\", ({ enumerable: true, get: function () { return ColumnFormatter_1.ColumnFormatter; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/parser/column/index.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/parser/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/parser/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = exports.Token = exports.Scanner = exports.RowParser = exports.Parser = void 0;\nvar Parser_1 = __webpack_require__(/*! ./Parser */ \"./node_modules/@fast-csv/parse/build/src/parser/Parser.js\");\nObject.defineProperty(exports, \"Parser\", ({ enumerable: true, get: function () { return Parser_1.Parser; } }));\nvar RowParser_1 = __webpack_require__(/*! ./RowParser */ \"./node_modules/@fast-csv/parse/build/src/parser/RowParser.js\");\nObject.defineProperty(exports, \"RowParser\", ({ enumerable: true, get: function () { return RowParser_1.RowParser; } }));\nvar Scanner_1 = __webpack_require__(/*! ./Scanner */ \"./node_modules/@fast-csv/parse/build/src/parser/Scanner.js\");\nObject.defineProperty(exports, \"Scanner\", ({ enumerable: true, get: function () { return Scanner_1.Scanner; } }));\nvar Token_1 = __webpack_require__(/*! ./Token */ \"./node_modules/@fast-csv/parse/build/src/parser/Token.js\");\nObject.defineProperty(exports, \"Token\", ({ enumerable: true, get: function () { return Token_1.Token; } }));\nvar column_1 = __webpack_require__(/*! ./column */ \"./node_modules/@fast-csv/parse/build/src/parser/column/index.js\");\nObject.defineProperty(exports, \"ColumnParser\", ({ enumerable: true, get: function () { return column_1.ColumnParser; } }));\nObject.defineProperty(exports, \"NonQuotedColumnParser\", ({ enumerable: true, get: function () { return column_1.NonQuotedColumnParser; } }));\nObject.defineProperty(exports, \"QuotedColumnParser\", ({ enumerable: true, get: function () { return column_1.QuotedColumnParser; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/parser/index.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/transforms/HeaderTransformer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/transforms/HeaderTransformer.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HeaderTransformer = void 0;\nconst lodash_isundefined_1 = __importDefault(__webpack_require__(/*! lodash.isundefined */ \"./node_modules/lodash.isundefined/index.js\"));\nconst lodash_isfunction_1 = __importDefault(__webpack_require__(/*! lodash.isfunction */ \"./node_modules/lodash.isfunction/index.js\"));\nconst lodash_uniq_1 = __importDefault(__webpack_require__(/*! lodash.uniq */ \"./node_modules/lodash.uniq/index.js\"));\nconst lodash_groupby_1 = __importDefault(__webpack_require__(/*! lodash.groupby */ \"./node_modules/lodash.groupby/index.js\"));\nclass HeaderTransformer {\n    parserOptions;\n    headers = null;\n    receivedHeaders = false;\n    shouldUseFirstRow = false;\n    processedFirstRow = false;\n    headersLength = 0;\n    headersTransform;\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        if (parserOptions.headers === true) {\n            this.shouldUseFirstRow = true;\n        }\n        else if (Array.isArray(parserOptions.headers)) {\n            this.setHeaders(parserOptions.headers);\n        }\n        else if ((0, lodash_isfunction_1.default)(parserOptions.headers)) {\n            this.headersTransform = parserOptions.headers;\n        }\n    }\n    transform(row, cb) {\n        if (!this.shouldMapRow(row)) {\n            return cb(null, { row: null, isValid: true });\n        }\n        return cb(null, this.processRow(row));\n    }\n    shouldMapRow(row) {\n        const { parserOptions } = this;\n        if (!this.headersTransform && parserOptions.renameHeaders && !this.processedFirstRow) {\n            if (!this.receivedHeaders) {\n                throw new Error('Error renaming headers: new headers must be provided in an array');\n            }\n            this.processedFirstRow = true;\n            return false;\n        }\n        if (!this.receivedHeaders && Array.isArray(row)) {\n            if (this.headersTransform) {\n                this.setHeaders(this.headersTransform(row));\n            }\n            else if (this.shouldUseFirstRow) {\n                this.setHeaders(row);\n            }\n            else {\n                // dont do anything with the headers if we didnt receive a transform or shouldnt use the first row.\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    processRow(row) {\n        if (!this.headers) {\n            return { row: row, isValid: true };\n        }\n        const { parserOptions } = this;\n        if (!parserOptions.discardUnmappedColumns && row.length > this.headersLength) {\n            if (!parserOptions.strictColumnHandling) {\n                throw new Error(`Unexpected Error: column header mismatch expected: ${this.headersLength} columns got: ${row.length}`);\n            }\n            return {\n                row: row,\n                isValid: false,\n                reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`,\n            };\n        }\n        if (parserOptions.strictColumnHandling && row.length < this.headersLength) {\n            return {\n                row: row,\n                isValid: false,\n                reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`,\n            };\n        }\n        return { row: this.mapHeaders(row), isValid: true };\n    }\n    mapHeaders(row) {\n        const rowMap = {};\n        const { headers, headersLength } = this;\n        for (let i = 0; i < headersLength; i += 1) {\n            const header = headers[i];\n            if (!(0, lodash_isundefined_1.default)(header)) {\n                const val = row[i];\n                // eslint-disable-next-line no-param-reassign\n                if ((0, lodash_isundefined_1.default)(val)) {\n                    rowMap[header] = '';\n                }\n                else {\n                    rowMap[header] = val;\n                }\n            }\n        }\n        return rowMap;\n    }\n    setHeaders(headers) {\n        const filteredHeaders = headers.filter((h) => {\n            return !!h;\n        });\n        if ((0, lodash_uniq_1.default)(filteredHeaders).length !== filteredHeaders.length) {\n            const grouped = (0, lodash_groupby_1.default)(filteredHeaders);\n            const duplicates = Object.keys(grouped).filter((dup) => {\n                return grouped[dup].length > 1;\n            });\n            throw new Error(`Duplicate headers found ${JSON.stringify(duplicates)}`);\n        }\n        this.headers = headers;\n        this.receivedHeaders = true;\n        this.headersLength = this.headers?.length || 0;\n    }\n}\nexports.HeaderTransformer = HeaderTransformer;\n//# sourceMappingURL=HeaderTransformer.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/transforms/HeaderTransformer.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/transforms/RowTransformerValidator.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/transforms/RowTransformerValidator.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RowTransformerValidator = void 0;\nconst lodash_isfunction_1 = __importDefault(__webpack_require__(/*! lodash.isfunction */ \"./node_modules/lodash.isfunction/index.js\"));\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/@fast-csv/parse/build/src/types.js\");\nclass RowTransformerValidator {\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    static createTransform(transformFunction) {\n        if ((0, types_1.isSyncTransform)(transformFunction)) {\n            return (row, cb) => {\n                let transformed = null;\n                try {\n                    transformed = transformFunction(row);\n                }\n                catch (e) {\n                    return cb(e);\n                }\n                return cb(null, transformed);\n            };\n        }\n        return transformFunction;\n    }\n    static createValidator(validateFunction) {\n        if ((0, types_1.isSyncValidate)(validateFunction)) {\n            return (row, cb) => {\n                cb(null, { row, isValid: validateFunction(row) });\n            };\n        }\n        return (row, cb) => {\n            validateFunction(row, (err, isValid, reason) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (isValid) {\n                    return cb(null, { row, isValid, reason });\n                }\n                return cb(null, { row, isValid: false, reason });\n            });\n        };\n    }\n    _rowTransform = null;\n    _rowValidator = null;\n    set rowTransform(transformFunction) {\n        if (!(0, lodash_isfunction_1.default)(transformFunction)) {\n            throw new TypeError('The transform should be a function');\n        }\n        this._rowTransform = RowTransformerValidator.createTransform(transformFunction);\n    }\n    set rowValidator(validateFunction) {\n        if (!(0, lodash_isfunction_1.default)(validateFunction)) {\n            throw new TypeError('The validate should be a function');\n        }\n        this._rowValidator = RowTransformerValidator.createValidator(validateFunction);\n    }\n    transformAndValidate(row, cb) {\n        return this.callTransformer(row, (transformErr, transformedRow) => {\n            if (transformErr) {\n                return cb(transformErr);\n            }\n            if (!transformedRow) {\n                return cb(null, { row: null, isValid: true });\n            }\n            return this.callValidator(transformedRow, (validateErr, validationResult) => {\n                if (validateErr) {\n                    return cb(validateErr);\n                }\n                if (validationResult && !validationResult.isValid) {\n                    return cb(null, { row: transformedRow, isValid: false, reason: validationResult.reason });\n                }\n                return cb(null, { row: transformedRow, isValid: true });\n            });\n        });\n    }\n    callTransformer(row, cb) {\n        if (!this._rowTransform) {\n            return cb(null, row);\n        }\n        return this._rowTransform(row, cb);\n    }\n    callValidator(row, cb) {\n        if (!this._rowValidator) {\n            return cb(null, { row, isValid: true });\n        }\n        return this._rowValidator(row, cb);\n    }\n}\nexports.RowTransformerValidator = RowTransformerValidator;\n//# sourceMappingURL=RowTransformerValidator.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/transforms/RowTransformerValidator.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/transforms/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/transforms/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HeaderTransformer = exports.RowTransformerValidator = void 0;\nvar RowTransformerValidator_1 = __webpack_require__(/*! ./RowTransformerValidator */ \"./node_modules/@fast-csv/parse/build/src/transforms/RowTransformerValidator.js\");\nObject.defineProperty(exports, \"RowTransformerValidator\", ({ enumerable: true, get: function () { return RowTransformerValidator_1.RowTransformerValidator; } }));\nvar HeaderTransformer_1 = __webpack_require__(/*! ./HeaderTransformer */ \"./node_modules/@fast-csv/parse/build/src/transforms/HeaderTransformer.js\");\nObject.defineProperty(exports, \"HeaderTransformer\", ({ enumerable: true, get: function () { return HeaderTransformer_1.HeaderTransformer; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/transforms/index.js?");

/***/ }),

/***/ "./node_modules/@fast-csv/parse/build/src/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/@fast-csv/parse/build/src/types.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSyncValidate = exports.isSyncTransform = void 0;\nconst isSyncTransform = (transform) => {\n    return transform.length === 1;\n};\nexports.isSyncTransform = isSyncTransform;\nconst isSyncValidate = (validate) => {\n    return validate.length === 1;\n};\nexports.isSyncValidate = isSyncValidate;\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/@fast-csv/parse/build/src/types.js?");

/***/ }),

/***/ "./node_modules/bindings/bindings.js":
/*!*******************************************!*\
  !*** ./node_modules/bindings/bindings.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nvar fs = __webpack_require__(/*! fs */ \"fs\"),\n  path = __webpack_require__(/*! path */ \"path\"),\n  fileURLToPath = __webpack_require__(/*! file-uri-to-path */ \"./node_modules/file-uri-to-path/index.js\"),\n  join = path.join,\n  dirname = path.dirname,\n  exists =\n    (fs.accessSync &&\n      function(path) {\n        try {\n          fs.accessSync(path);\n        } catch (e) {\n          return false;\n        }\n        return true;\n      }) ||\n    fs.existsSync ||\n    path.existsSync,\n  defaults = {\n    arrow: process.env.NODE_BINDINGS_ARROW || '  ',\n    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled',\n    platform: process.platform,\n    arch: process.arch,\n    nodePreGyp:\n      'node-v' +\n      process.versions.modules +\n      '-' +\n      process.platform +\n      '-' +\n      process.arch,\n    version: process.versions.node,\n    bindings: 'bindings.node',\n    try: [\n      // node-gyp's linked version in the \"build\" dir\n      ['module_root', 'build', 'bindings'],\n      // node-waf and gyp_addon (a.k.a node-gyp)\n      ['module_root', 'build', 'Debug', 'bindings'],\n      ['module_root', 'build', 'Release', 'bindings'],\n      // Debug files, for development (legacy behavior, remove for node v0.9)\n      ['module_root', 'out', 'Debug', 'bindings'],\n      ['module_root', 'Debug', 'bindings'],\n      // Release files, but manually compiled (legacy behavior, remove for node v0.9)\n      ['module_root', 'out', 'Release', 'bindings'],\n      ['module_root', 'Release', 'bindings'],\n      // Legacy from node-waf, node <= 0.4.x\n      ['module_root', 'build', 'default', 'bindings'],\n      // Production \"Release\" buildtype binary (meh...)\n      ['module_root', 'compiled', 'version', 'platform', 'arch', 'bindings'],\n      // node-qbs builds\n      ['module_root', 'addon-build', 'release', 'install-root', 'bindings'],\n      ['module_root', 'addon-build', 'debug', 'install-root', 'bindings'],\n      ['module_root', 'addon-build', 'default', 'install-root', 'bindings'],\n      // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}\n      ['module_root', 'lib', 'binding', 'nodePreGyp', 'bindings']\n    ]\n  };\n\n/**\n * The main `bindings()` function loads the compiled bindings for a given module.\n * It uses V8's Error API to determine the parent filename that this function is\n * being invoked from, which is then used to find the root directory.\n */\n\nfunction bindings(opts) {\n  // Argument surgery\n  if (typeof opts == 'string') {\n    opts = { bindings: opts };\n  } else if (!opts) {\n    opts = {};\n  }\n\n  // maps `defaults` onto `opts` object\n  Object.keys(defaults).map(function(i) {\n    if (!(i in opts)) opts[i] = defaults[i];\n  });\n\n  // Get the module root\n  if (!opts.module_root) {\n    opts.module_root = exports.getRoot(exports.getFileName());\n  }\n\n  // Ensure the given bindings name ends with .node\n  if (path.extname(opts.bindings) != '.node') {\n    opts.bindings += '.node';\n  }\n\n  // https://github.com/webpack/webpack/issues/4175#issuecomment-342931035\n  var requireFunc =\n     true\n      ? require\n      : 0;\n\n  var tries = [],\n    i = 0,\n    l = opts.try.length,\n    n,\n    b,\n    err;\n\n  for (; i < l; i++) {\n    n = join.apply(\n      null,\n      opts.try[i].map(function(p) {\n        return opts[p] || p;\n      })\n    );\n    tries.push(n);\n    try {\n      b = opts.path ? requireFunc.resolve(n) : requireFunc(n);\n      if (!opts.path) {\n        b.path = n;\n      }\n      return b;\n    } catch (e) {\n      if (e.code !== 'MODULE_NOT_FOUND' &&\n          e.code !== 'QUALIFIED_PATH_RESOLUTION_FAILED' &&\n          !/not find/i.test(e.message)) {\n        throw e;\n      }\n    }\n  }\n\n  err = new Error(\n    'Could not locate the bindings file. Tried:\\n' +\n      tries\n        .map(function(a) {\n          return opts.arrow + a;\n        })\n        .join('\\n')\n  );\n  err.tries = tries;\n  throw err;\n}\nmodule.exports = exports = bindings;\n\n/**\n * Gets the filename of the JavaScript file that invokes this function.\n * Used to help find the root directory of a module.\n * Optionally accepts an filename argument to skip when searching for the invoking filename\n */\n\nexports.getFileName = function getFileName(calling_file) {\n  var origPST = Error.prepareStackTrace,\n    origSTL = Error.stackTraceLimit,\n    dummy = {},\n    fileName;\n\n  Error.stackTraceLimit = 10;\n\n  Error.prepareStackTrace = function(e, st) {\n    for (var i = 0, l = st.length; i < l; i++) {\n      fileName = st[i].getFileName();\n      if (fileName !== __filename) {\n        if (calling_file) {\n          if (fileName !== calling_file) {\n            return;\n          }\n        } else {\n          return;\n        }\n      }\n    }\n  };\n\n  // run the 'prepareStackTrace' function above\n  Error.captureStackTrace(dummy);\n  dummy.stack;\n\n  // cleanup\n  Error.prepareStackTrace = origPST;\n  Error.stackTraceLimit = origSTL;\n\n  // handle filename that starts with \"file://\"\n  var fileSchema = 'file://';\n  if (fileName.indexOf(fileSchema) === 0) {\n    fileName = fileURLToPath(fileName);\n  }\n\n  return fileName;\n};\n\n/**\n * Gets the root directory of a module, given an arbitrary filename\n * somewhere in the module tree. The \"root directory\" is the directory\n * containing the `package.json` file.\n *\n *   In:  /home/nate/node-native-module/lib/index.js\n *   Out: /home/nate/node-native-module\n */\n\nexports.getRoot = function getRoot(file) {\n  var dir = dirname(file),\n    prev;\n  while (true) {\n    if (dir === '.') {\n      // Avoids an infinite loop in rare cases, like the REPL\n      dir = process.cwd();\n    }\n    if (\n      exists(join(dir, 'package.json')) ||\n      exists(join(dir, 'node_modules'))\n    ) {\n      // Found the 'package.json' file or 'node_modules' dir; we're done\n      return dir;\n    }\n    if (prev === dir) {\n      // Got to the top\n      throw new Error(\n        'Could not find module root given file: \"' +\n          file +\n          '\". Do you have a `package.json` file? '\n      );\n    }\n    // Try the parent dir next\n    prev = dir;\n    dir = join(dir, '..');\n  }\n};\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/bindings/bindings.js?");

/***/ }),

/***/ "./node_modules/fast-csv/build/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-csv/build/src/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CsvParserStream = exports.ParserOptions = exports.parseFile = exports.parseStream = exports.parseString = exports.parse = exports.FormatterOptions = exports.CsvFormatterStream = exports.writeToPath = exports.writeToString = exports.writeToBuffer = exports.writeToStream = exports.write = exports.format = void 0;\nvar format_1 = __webpack_require__(/*! @fast-csv/format */ \"./node_modules/@fast-csv/format/build/src/index.js\");\nObject.defineProperty(exports, \"format\", ({ enumerable: true, get: function () { return format_1.format; } }));\nObject.defineProperty(exports, \"write\", ({ enumerable: true, get: function () { return format_1.write; } }));\nObject.defineProperty(exports, \"writeToStream\", ({ enumerable: true, get: function () { return format_1.writeToStream; } }));\nObject.defineProperty(exports, \"writeToBuffer\", ({ enumerable: true, get: function () { return format_1.writeToBuffer; } }));\nObject.defineProperty(exports, \"writeToString\", ({ enumerable: true, get: function () { return format_1.writeToString; } }));\nObject.defineProperty(exports, \"writeToPath\", ({ enumerable: true, get: function () { return format_1.writeToPath; } }));\nObject.defineProperty(exports, \"CsvFormatterStream\", ({ enumerable: true, get: function () { return format_1.CsvFormatterStream; } }));\nObject.defineProperty(exports, \"FormatterOptions\", ({ enumerable: true, get: function () { return format_1.FormatterOptions; } }));\nvar parse_1 = __webpack_require__(/*! @fast-csv/parse */ \"./node_modules/@fast-csv/parse/build/src/index.js\");\nObject.defineProperty(exports, \"parse\", ({ enumerable: true, get: function () { return parse_1.parse; } }));\nObject.defineProperty(exports, \"parseString\", ({ enumerable: true, get: function () { return parse_1.parseString; } }));\nObject.defineProperty(exports, \"parseStream\", ({ enumerable: true, get: function () { return parse_1.parseStream; } }));\nObject.defineProperty(exports, \"parseFile\", ({ enumerable: true, get: function () { return parse_1.parseFile; } }));\nObject.defineProperty(exports, \"ParserOptions\", ({ enumerable: true, get: function () { return parse_1.ParserOptions; } }));\nObject.defineProperty(exports, \"CsvParserStream\", ({ enumerable: true, get: function () { return parse_1.CsvParserStream; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/fast-csv/build/src/index.js?");

/***/ }),

/***/ "./node_modules/file-uri-to-path/index.js":
/*!************************************************!*\
  !*** ./node_modules/file-uri-to-path/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Module dependencies.\n */\n\nvar sep = (__webpack_require__(/*! path */ \"path\").sep) || '/';\n\n/**\n * Module exports.\n */\n\nmodule.exports = fileUriToPath;\n\n/**\n * File URI to Path function.\n *\n * @param {String} uri\n * @return {String} path\n * @api public\n */\n\nfunction fileUriToPath (uri) {\n  if ('string' != typeof uri ||\n      uri.length <= 7 ||\n      'file://' != uri.substring(0, 7)) {\n    throw new TypeError('must pass in a file:// URI to convert to a file path');\n  }\n\n  var rest = decodeURI(uri.substring(7));\n  var firstSlash = rest.indexOf('/');\n  var host = rest.substring(0, firstSlash);\n  var path = rest.substring(firstSlash + 1);\n\n  // 2.  Scheme Definition\n  // As a special case, <host> can be the string \"localhost\" or the empty\n  // string; this is interpreted as \"the machine from which the URL is\n  // being interpreted\".\n  if ('localhost' == host) host = '';\n\n  if (host) {\n    host = sep + sep + host;\n  }\n\n  // 3.2  Drives, drive letters, mount points, file system root\n  // Drive letters are mapped into the top of a file URI in various ways,\n  // depending on the implementation; some applications substitute\n  // vertical bar (\"|\") for the colon after the drive letter, yielding\n  // \"file:///c|/tmp/test.txt\".  In some cases, the colon is left\n  // unchanged, as in \"file:///c:/tmp/test.txt\".  In other cases, the\n  // colon is simply omitted, as in \"file:///c/tmp/test.txt\".\n  path = path.replace(/^(.+)\\|/, '$1:');\n\n  // for Windows, we need to invert the path separators from what a URI uses\n  if (sep == '\\\\') {\n    path = path.replace(/\\//g, '\\\\');\n  }\n\n  if (/^.+\\:/.test(path)) {\n    // has Windows drive at beginning of path\n  } else {\n    // unix path\n    path = sep + path;\n  }\n\n  return host + path;\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/file-uri-to-path/index.js?");

/***/ }),

/***/ "./node_modules/lodash.escaperegexp/index.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash.escaperegexp/index.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n    reHasRegExpChar = RegExp(reRegExpChar.source);\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n */\nfunction escapeRegExp(string) {\n  string = toString(string);\n  return (string && reHasRegExpChar.test(string))\n    ? string.replace(reRegExpChar, '\\\\$&')\n    : string;\n}\n\nmodule.exports = escapeRegExp;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lodash.escaperegexp/index.js?");

/***/ }),

/***/ "./node_modules/lodash.groupby/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash.groupby/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {boolean} [bitmask] The bitmask of comparison flags.\n *  The bitmask may be composed of the following flags:\n *     1 - Unordered comparison\n *     2 - Partial comparison\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = getTag(object);\n    objTag = objTag == argsTag ? objectTag : objTag;\n  }\n  if (!othIsArr) {\n    othTag = getTag(other);\n    othTag = othTag == argsTag ? objectTag : othTag;\n  }\n  var objIsObj = objTag == objectTag && !isHostObject(object),\n      othIsObj = othTag == objectTag && !isHostObject(other),\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n  }\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!seen.has(othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, customizer, bitmask, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= UNORDERED_COMPARE_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var result,\n      index = -1,\n      length = path.length;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result) {\n    return result;\n  }\n  var length = object ? object.length : 0;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity]\n *  The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    result[key] = [value];\n  }\n});\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = groupBy;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lodash.groupby/index.js?");

/***/ }),

/***/ "./node_modules/lodash.isboolean/index.js":
/*!************************************************!*\
  !*** ./node_modules/lodash.isboolean/index.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a boolean primitive or object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isBoolean(false);\n * // => true\n *\n * _.isBoolean(null);\n * // => false\n */\nfunction isBoolean(value) {\n  return value === true || value === false ||\n    (isObjectLike(value) && objectToString.call(value) == boolTag);\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isBoolean;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lodash.isboolean/index.js?");

/***/ }),

/***/ "./node_modules/lodash.isequal/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash.isequal/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lodash.isequal/index.js?");

/***/ }),

/***/ "./node_modules/lodash.isfunction/index.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash.isfunction/index.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    nullTag = '[object Null]',\n    proxyTag = '[object Proxy]',\n    undefinedTag = '[object Undefined]';\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isFunction;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lodash.isfunction/index.js?");

/***/ }),

/***/ "./node_modules/lodash.isnil/index.js":
/*!********************************************!*\
  !*** ./node_modules/lodash.isnil/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * lodash 4.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Checks if `value` is `null` or `undefined`.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n * @example\n *\n * _.isNil(null);\n * // => true\n *\n * _.isNil(void 0);\n * // => true\n *\n * _.isNil(NaN);\n * // => false\n */\nfunction isNil(value) {\n  return value == null;\n}\n\nmodule.exports = isNil;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lodash.isnil/index.js?");

/***/ }),

/***/ "./node_modules/lodash.isundefined/index.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash.isundefined/index.js ***!
  \**************************************************/
/***/ ((module) => {

eval("/**\n * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Checks if `value` is `undefined`.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n * @example\n *\n * _.isUndefined(void 0);\n * // => true\n *\n * _.isUndefined(null);\n * // => false\n */\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nmodule.exports = isUndefined;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lodash.isundefined/index.js?");

/***/ }),

/***/ "./node_modules/lodash.uniq/index.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash.uniq/index.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array ? array.length : 0;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\n/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * Checks if a cache value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    Set = getNative(root, 'Set'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each\n * element is kept.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length)\n    ? baseUniq(array)\n    : [];\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = uniq;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lodash.uniq/index.js?");

/***/ }),

/***/ "./node_modules/lowdb/lib/adapters/Memory.js":
/*!***************************************************!*\
  !*** ./node_modules/lowdb/lib/adapters/Memory.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Memory: () => (/* binding */ Memory),\n/* harmony export */   MemorySync: () => (/* binding */ MemorySync)\n/* harmony export */ });\nclass Memory {\n    #data = null;\n    read() {\n        return Promise.resolve(this.#data);\n    }\n    write(obj) {\n        this.#data = obj;\n        return Promise.resolve();\n    }\n}\nclass MemorySync {\n    #data = null;\n    read() {\n        return this.#data || null;\n    }\n    write(obj) {\n        this.#data = obj;\n    }\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lowdb/lib/adapters/Memory.js?");

/***/ }),

/***/ "./node_modules/lowdb/lib/adapters/node/DataFile.js":
/*!**********************************************************!*\
  !*** ./node_modules/lowdb/lib/adapters/node/DataFile.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataFile: () => (/* binding */ DataFile),\n/* harmony export */   DataFileSync: () => (/* binding */ DataFileSync)\n/* harmony export */ });\n/* harmony import */ var _TextFile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextFile.js */ \"./node_modules/lowdb/lib/adapters/node/TextFile.js\");\n\nclass DataFile {\n    #adapter;\n    #parse;\n    #stringify;\n    constructor(filename, { parse, stringify, }) {\n        this.#adapter = new _TextFile_js__WEBPACK_IMPORTED_MODULE_0__.TextFile(filename);\n        this.#parse = parse;\n        this.#stringify = stringify;\n    }\n    async read() {\n        const data = await this.#adapter.read();\n        if (data === null) {\n            return null;\n        }\n        else {\n            return this.#parse(data);\n        }\n    }\n    write(obj) {\n        return this.#adapter.write(this.#stringify(obj));\n    }\n}\nclass DataFileSync {\n    #adapter;\n    #parse;\n    #stringify;\n    constructor(filename, { parse, stringify, }) {\n        this.#adapter = new _TextFile_js__WEBPACK_IMPORTED_MODULE_0__.TextFileSync(filename);\n        this.#parse = parse;\n        this.#stringify = stringify;\n    }\n    read() {\n        const data = this.#adapter.read();\n        if (data === null) {\n            return null;\n        }\n        else {\n            return this.#parse(data);\n        }\n    }\n    write(obj) {\n        this.#adapter.write(this.#stringify(obj));\n    }\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lowdb/lib/adapters/node/DataFile.js?");

/***/ }),

/***/ "./node_modules/lowdb/lib/adapters/node/JSONFile.js":
/*!**********************************************************!*\
  !*** ./node_modules/lowdb/lib/adapters/node/JSONFile.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONFile: () => (/* binding */ JSONFile),\n/* harmony export */   JSONFileSync: () => (/* binding */ JSONFileSync)\n/* harmony export */ });\n/* harmony import */ var _DataFile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataFile.js */ \"./node_modules/lowdb/lib/adapters/node/DataFile.js\");\n\nclass JSONFile extends _DataFile_js__WEBPACK_IMPORTED_MODULE_0__.DataFile {\n    constructor(filename) {\n        super(filename, {\n            parse: JSON.parse,\n            stringify: (data) => JSON.stringify(data, null, 2),\n        });\n    }\n}\nclass JSONFileSync extends _DataFile_js__WEBPACK_IMPORTED_MODULE_0__.DataFileSync {\n    constructor(filename) {\n        super(filename, {\n            parse: JSON.parse,\n            stringify: (data) => JSON.stringify(data, null, 2),\n        });\n    }\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lowdb/lib/adapters/node/JSONFile.js?");

/***/ }),

/***/ "./node_modules/lowdb/lib/adapters/node/TextFile.js":
/*!**********************************************************!*\
  !*** ./node_modules/lowdb/lib/adapters/node/TextFile.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextFile: () => (/* binding */ TextFile),\n/* harmony export */   TextFileSync: () => (/* binding */ TextFileSync)\n/* harmony export */ });\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var steno__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! steno */ \"./node_modules/steno/lib/index.js\");\n\n\n\n\nclass TextFile {\n    #filename;\n    #writer;\n    constructor(filename) {\n        this.#filename = filename;\n        this.#writer = new steno__WEBPACK_IMPORTED_MODULE_3__.Writer(filename);\n    }\n    async read() {\n        let data;\n        try {\n            data = await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_1__.readFile)(this.#filename, 'utf-8');\n        }\n        catch (e) {\n            if (e.code === 'ENOENT') {\n                return null;\n            }\n            throw e;\n        }\n        return data;\n    }\n    write(str) {\n        return this.#writer.write(str);\n    }\n}\nclass TextFileSync {\n    #tempFilename;\n    #filename;\n    constructor(filename) {\n        this.#filename = filename;\n        const f = filename.toString();\n        this.#tempFilename = node_path__WEBPACK_IMPORTED_MODULE_2__.join(node_path__WEBPACK_IMPORTED_MODULE_2__.dirname(f), `.${node_path__WEBPACK_IMPORTED_MODULE_2__.basename(f)}.tmp`);\n    }\n    read() {\n        let data;\n        try {\n            data = (0,node_fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync)(this.#filename, 'utf-8');\n        }\n        catch (e) {\n            if (e.code === 'ENOENT') {\n                return null;\n            }\n            throw e;\n        }\n        return data;\n    }\n    write(str) {\n        (0,node_fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync)(this.#tempFilename, str);\n        (0,node_fs__WEBPACK_IMPORTED_MODULE_0__.renameSync)(this.#tempFilename, this.#filename);\n    }\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lowdb/lib/adapters/node/TextFile.js?");

/***/ }),

/***/ "./node_modules/lowdb/lib/core/Low.js":
/*!********************************************!*\
  !*** ./node_modules/lowdb/lib/core/Low.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Low: () => (/* binding */ Low),\n/* harmony export */   LowSync: () => (/* binding */ LowSync)\n/* harmony export */ });\nfunction checkArgs(adapter, defaultData) {\n    if (adapter === undefined)\n        throw new Error('lowdb: missing adapter');\n    if (defaultData === undefined)\n        throw new Error('lowdb: missing default data');\n}\nclass Low {\n    adapter;\n    data;\n    constructor(adapter, defaultData) {\n        checkArgs(adapter, defaultData);\n        this.adapter = adapter;\n        this.data = defaultData;\n    }\n    async read() {\n        const data = await this.adapter.read();\n        if (data)\n            this.data = data;\n    }\n    async write() {\n        if (this.data)\n            await this.adapter.write(this.data);\n    }\n    async update(fn) {\n        fn(this.data);\n        await this.write();\n    }\n}\nclass LowSync {\n    adapter;\n    data;\n    constructor(adapter, defaultData) {\n        checkArgs(adapter, defaultData);\n        this.adapter = adapter;\n        this.data = defaultData;\n    }\n    read() {\n        const data = this.adapter.read();\n        if (data)\n            this.data = data;\n    }\n    write() {\n        if (this.data)\n            this.adapter.write(this.data);\n    }\n    update(fn) {\n        fn(this.data);\n        this.write();\n    }\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lowdb/lib/core/Low.js?");

/***/ }),

/***/ "./node_modules/lowdb/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lowdb/lib/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Low: () => (/* reexport safe */ _core_Low_js__WEBPACK_IMPORTED_MODULE_1__.Low),\n/* harmony export */   LowSync: () => (/* reexport safe */ _core_Low_js__WEBPACK_IMPORTED_MODULE_1__.LowSync),\n/* harmony export */   Memory: () => (/* reexport safe */ _adapters_Memory_js__WEBPACK_IMPORTED_MODULE_0__.Memory),\n/* harmony export */   MemorySync: () => (/* reexport safe */ _adapters_Memory_js__WEBPACK_IMPORTED_MODULE_0__.MemorySync)\n/* harmony export */ });\n/* harmony import */ var _adapters_Memory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapters/Memory.js */ \"./node_modules/lowdb/lib/adapters/Memory.js\");\n/* harmony import */ var _core_Low_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/Low.js */ \"./node_modules/lowdb/lib/core/Low.js\");\n\n\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lowdb/lib/index.js?");

/***/ }),

/***/ "./node_modules/lowdb/lib/node.js":
/*!****************************************!*\
  !*** ./node_modules/lowdb/lib/node.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataFile: () => (/* reexport safe */ _adapters_node_DataFile_js__WEBPACK_IMPORTED_MODULE_0__.DataFile),\n/* harmony export */   DataFileSync: () => (/* reexport safe */ _adapters_node_DataFile_js__WEBPACK_IMPORTED_MODULE_0__.DataFileSync),\n/* harmony export */   JSONFile: () => (/* reexport safe */ _adapters_node_JSONFile_js__WEBPACK_IMPORTED_MODULE_1__.JSONFile),\n/* harmony export */   JSONFilePreset: () => (/* reexport safe */ _presets_node_js__WEBPACK_IMPORTED_MODULE_3__.JSONFilePreset),\n/* harmony export */   JSONFileSync: () => (/* reexport safe */ _adapters_node_JSONFile_js__WEBPACK_IMPORTED_MODULE_1__.JSONFileSync),\n/* harmony export */   JSONFileSyncPreset: () => (/* reexport safe */ _presets_node_js__WEBPACK_IMPORTED_MODULE_3__.JSONFileSyncPreset),\n/* harmony export */   TextFile: () => (/* reexport safe */ _adapters_node_TextFile_js__WEBPACK_IMPORTED_MODULE_2__.TextFile),\n/* harmony export */   TextFileSync: () => (/* reexport safe */ _adapters_node_TextFile_js__WEBPACK_IMPORTED_MODULE_2__.TextFileSync)\n/* harmony export */ });\n/* harmony import */ var _adapters_node_DataFile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapters/node/DataFile.js */ \"./node_modules/lowdb/lib/adapters/node/DataFile.js\");\n/* harmony import */ var _adapters_node_JSONFile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapters/node/JSONFile.js */ \"./node_modules/lowdb/lib/adapters/node/JSONFile.js\");\n/* harmony import */ var _adapters_node_TextFile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adapters/node/TextFile.js */ \"./node_modules/lowdb/lib/adapters/node/TextFile.js\");\n/* harmony import */ var _presets_node_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./presets/node.js */ \"./node_modules/lowdb/lib/presets/node.js\");\n\n\n\n\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lowdb/lib/node.js?");

/***/ }),

/***/ "./node_modules/lowdb/lib/presets/node.js":
/*!************************************************!*\
  !*** ./node_modules/lowdb/lib/presets/node.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONFilePreset: () => (/* binding */ JSONFilePreset),\n/* harmony export */   JSONFileSyncPreset: () => (/* binding */ JSONFileSyncPreset)\n/* harmony export */ });\n/* harmony import */ var _adapters_Memory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adapters/Memory.js */ \"./node_modules/lowdb/lib/adapters/Memory.js\");\n/* harmony import */ var _adapters_node_JSONFile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../adapters/node/JSONFile.js */ \"./node_modules/lowdb/lib/adapters/node/JSONFile.js\");\n/* harmony import */ var _core_Low_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Low.js */ \"./node_modules/lowdb/lib/core/Low.js\");\n\n\n\nasync function JSONFilePreset(filename, defaultData) {\n    const adapter =  false\n        ? 0\n        : new _adapters_node_JSONFile_js__WEBPACK_IMPORTED_MODULE_1__.JSONFile(filename);\n    const db = new _core_Low_js__WEBPACK_IMPORTED_MODULE_2__.Low(adapter, defaultData);\n    await db.read();\n    return db;\n}\nfunction JSONFileSyncPreset(filename, defaultData) {\n    const adapter =  false\n        ? 0\n        : new _adapters_node_JSONFile_js__WEBPACK_IMPORTED_MODULE_1__.JSONFileSync(filename);\n    const db = new _core_Low_js__WEBPACK_IMPORTED_MODULE_2__.LowSync(adapter, defaultData);\n    db.read();\n    return db;\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/lowdb/lib/presets/node.js?");

/***/ }),

/***/ "./node_modules/nanoid/index.js":
/*!**************************************!*\
  !*** ./node_modules/nanoid/index.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   customRandom: () => (/* binding */ customRandom),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   urlAlphabet: () => (/* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__.urlAlphabet)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./url-alphabet/index.js */ \"./node_modules/nanoid/url-alphabet/index.js\");\n\n\n\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\nfunction fillPool(bytes) {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto.getRandomValues(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto.getRandomValues(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\nfunction random(bytes) {\n  fillPool((bytes |= 0))\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\nfunction customRandom(alphabet, defaultSize, getRandom) {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nfunction customAlphabet(alphabet, size = 21) {\n  return customRandom(alphabet, size, random)\n}\nfunction nanoid(size = 21) {\n  fillPool((size |= 0))\n  let id = ''\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    id += _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__.urlAlphabet[pool[i] & 63]\n  }\n  return id\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/nanoid/index.js?");

/***/ }),

/***/ "./node_modules/nanoid/url-alphabet/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nanoid/url-alphabet/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   urlAlphabet: () => (/* binding */ urlAlphabet)\n/* harmony export */ });\nconst urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/nanoid/url-alphabet/index.js?");

/***/ }),

/***/ "./node_modules/steno/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/steno/lib/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Writer: () => (/* binding */ Writer)\n/* harmony export */ });\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:url */ \"node:url\");\n\n\n\n// Returns a temporary file\n// Example: for /some/file will return /some/.file.tmp\nfunction getTempFilename(file) {\n    const f = file instanceof URL ? (0,node_url__WEBPACK_IMPORTED_MODULE_2__.fileURLToPath)(file) : file.toString();\n    return (0,node_path__WEBPACK_IMPORTED_MODULE_1__.join)((0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(f), `.${(0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(f)}.tmp`);\n}\n// Retries an asynchronous operation with a delay between retries and a maximum retry count\nasync function retryAsyncOperation(fn, maxRetries, delayMs) {\n    for (let i = 0; i < maxRetries; i++) {\n        try {\n            return await fn();\n        }\n        catch (error) {\n            if (i < maxRetries - 1) {\n                await new Promise((resolve) => setTimeout(resolve, delayMs));\n            }\n            else {\n                throw error; // Rethrow the error if max retries reached\n            }\n        }\n    }\n}\nclass Writer {\n    #filename;\n    #tempFilename;\n    #locked = false;\n    #prev = null;\n    #next = null;\n    #nextPromise = null;\n    #nextData = null;\n    // File is locked, add data for later\n    #add(data) {\n        // Only keep most recent data\n        this.#nextData = data;\n        // Create a singleton promise to resolve all next promises once next data is written\n        this.#nextPromise ||= new Promise((resolve, reject) => {\n            this.#next = [resolve, reject];\n        });\n        // Return a promise that will resolve at the same time as next promise\n        return new Promise((resolve, reject) => {\n            this.#nextPromise?.then(resolve).catch(reject);\n        });\n    }\n    // File isn't locked, write data\n    async #write(data) {\n        // Lock file\n        this.#locked = true;\n        try {\n            // Atomic write\n            await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_0__.writeFile)(this.#tempFilename, data, 'utf-8');\n            await retryAsyncOperation(async () => {\n                await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_0__.rename)(this.#tempFilename, this.#filename);\n            }, 10, 100);\n            // Call resolve\n            this.#prev?.[0]();\n        }\n        catch (err) {\n            // Call reject\n            if (err instanceof Error) {\n                this.#prev?.[1](err);\n            }\n            throw err;\n        }\n        finally {\n            // Unlock file\n            this.#locked = false;\n            this.#prev = this.#next;\n            this.#next = this.#nextPromise = null;\n            if (this.#nextData !== null) {\n                const nextData = this.#nextData;\n                this.#nextData = null;\n                await this.write(nextData);\n            }\n        }\n    }\n    constructor(filename) {\n        this.#filename = filename;\n        this.#tempFilename = getTempFilename(filename);\n    }\n    async write(data) {\n        return this.#locked ? this.#add(data) : this.#write(data);\n    }\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/steno/lib/index.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/index.js":
/*!*********************************************!*\
  !*** ./node_modules/uuid/dist/cjs/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;\nvar max_js_1 = __webpack_require__(/*! ./max.js */ \"./node_modules/uuid/dist/cjs/max.js\");\nObject.defineProperty(exports, \"MAX\", ({ enumerable: true, get: function () { return max_js_1.default; } }));\nvar nil_js_1 = __webpack_require__(/*! ./nil.js */ \"./node_modules/uuid/dist/cjs/nil.js\");\nObject.defineProperty(exports, \"NIL\", ({ enumerable: true, get: function () { return nil_js_1.default; } }));\nvar parse_js_1 = __webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/cjs/parse.js\");\nObject.defineProperty(exports, \"parse\", ({ enumerable: true, get: function () { return parse_js_1.default; } }));\nvar stringify_js_1 = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/cjs/stringify.js\");\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return stringify_js_1.default; } }));\nvar v1_js_1 = __webpack_require__(/*! ./v1.js */ \"./node_modules/uuid/dist/cjs/v1.js\");\nObject.defineProperty(exports, \"v1\", ({ enumerable: true, get: function () { return v1_js_1.default; } }));\nvar v1ToV6_js_1 = __webpack_require__(/*! ./v1ToV6.js */ \"./node_modules/uuid/dist/cjs/v1ToV6.js\");\nObject.defineProperty(exports, \"v1ToV6\", ({ enumerable: true, get: function () { return v1ToV6_js_1.default; } }));\nvar v3_js_1 = __webpack_require__(/*! ./v3.js */ \"./node_modules/uuid/dist/cjs/v3.js\");\nObject.defineProperty(exports, \"v3\", ({ enumerable: true, get: function () { return v3_js_1.default; } }));\nvar v4_js_1 = __webpack_require__(/*! ./v4.js */ \"./node_modules/uuid/dist/cjs/v4.js\");\nObject.defineProperty(exports, \"v4\", ({ enumerable: true, get: function () { return v4_js_1.default; } }));\nvar v5_js_1 = __webpack_require__(/*! ./v5.js */ \"./node_modules/uuid/dist/cjs/v5.js\");\nObject.defineProperty(exports, \"v5\", ({ enumerable: true, get: function () { return v5_js_1.default; } }));\nvar v6_js_1 = __webpack_require__(/*! ./v6.js */ \"./node_modules/uuid/dist/cjs/v6.js\");\nObject.defineProperty(exports, \"v6\", ({ enumerable: true, get: function () { return v6_js_1.default; } }));\nvar v6ToV1_js_1 = __webpack_require__(/*! ./v6ToV1.js */ \"./node_modules/uuid/dist/cjs/v6ToV1.js\");\nObject.defineProperty(exports, \"v6ToV1\", ({ enumerable: true, get: function () { return v6ToV1_js_1.default; } }));\nvar v7_js_1 = __webpack_require__(/*! ./v7.js */ \"./node_modules/uuid/dist/cjs/v7.js\");\nObject.defineProperty(exports, \"v7\", ({ enumerable: true, get: function () { return v7_js_1.default; } }));\nvar validate_js_1 = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/cjs/validate.js\");\nObject.defineProperty(exports, \"validate\", ({ enumerable: true, get: function () { return validate_js_1.default; } }));\nvar version_js_1 = __webpack_require__(/*! ./version.js */ \"./node_modules/uuid/dist/cjs/version.js\");\nObject.defineProperty(exports, \"version\", ({ enumerable: true, get: function () { return version_js_1.default; } }));\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/index.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/max.js":
/*!*******************************************!*\
  !*** ./node_modules/uuid/dist/cjs/max.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = 'ffffffff-ffff-ffff-ffff-ffffffffffff';\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/max.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/md5.js":
/*!*******************************************!*\
  !*** ./node_modules/uuid/dist/cjs/md5.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nfunction md5(bytes) {\n    if (Array.isArray(bytes)) {\n        bytes = Buffer.from(bytes);\n    }\n    else if (typeof bytes === 'string') {\n        bytes = Buffer.from(bytes, 'utf8');\n    }\n    return (0, crypto_1.createHash)('md5').update(bytes).digest();\n}\nexports[\"default\"] = md5;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/md5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/native.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/dist/cjs/native.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nexports[\"default\"] = { randomUUID: crypto_1.randomUUID };\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/native.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/nil.js":
/*!*******************************************!*\
  !*** ./node_modules/uuid/dist/cjs/nil.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = '00000000-0000-0000-0000-000000000000';\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/nil.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/parse.js":
/*!*********************************************!*\
  !*** ./node_modules/uuid/dist/cjs/parse.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst validate_js_1 = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/cjs/validate.js\");\nfunction parse(uuid) {\n    if (!(0, validate_js_1.default)(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    let v;\n    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);\n}\nexports[\"default\"] = parse;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/parse.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/regex.js":
/*!*********************************************!*\
  !*** ./node_modules/uuid/dist/cjs/regex.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/regex.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/rng.js":
/*!*******************************************!*\
  !*** ./node_modules/uuid/dist/cjs/rng.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        (0, crypto_1.randomFillSync)(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\nexports[\"default\"] = rng;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/sha1.js":
/*!********************************************!*\
  !*** ./node_modules/uuid/dist/cjs/sha1.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nfunction sha1(bytes) {\n    if (Array.isArray(bytes)) {\n        bytes = Buffer.from(bytes);\n    }\n    else if (typeof bytes === 'string') {\n        bytes = Buffer.from(bytes, 'utf8');\n    }\n    return (0, crypto_1.createHash)('sha1').update(bytes).digest();\n}\nexports[\"default\"] = sha1;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/sha1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/stringify.js":
/*!*************************************************!*\
  !*** ./node_modules/uuid/dist/cjs/stringify.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unsafeStringify = void 0;\nconst validate_js_1 = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/cjs/validate.js\");\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nexports.unsafeStringify = unsafeStringify;\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!(0, validate_js_1.default)(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexports[\"default\"] = stringify;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/stringify.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/v1.js":
/*!******************************************!*\
  !*** ./node_modules/uuid/dist/cjs/v1.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.updateV1State = void 0;\nconst rng_js_1 = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/cjs/rng.js\");\nconst stringify_js_1 = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/cjs/stringify.js\");\nconst _state = {};\nfunction v1(options, buf, offset) {\n    let bytes;\n    const isV6 = options?._v6 ?? false;\n    if (options) {\n        const optionsKeys = Object.keys(options);\n        if (optionsKeys.length === 1 && optionsKeys[0] === '_v6') {\n            options = undefined;\n        }\n    }\n    if (options) {\n        bytes = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);\n    }\n    else {\n        const now = Date.now();\n        const rnds = (0, rng_js_1.default)();\n        updateV1State(_state, now, rnds);\n        bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? undefined : _state.clockseq, isV6 ? undefined : _state.node, buf, offset);\n    }\n    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);\n}\nfunction updateV1State(state, now, rnds) {\n    state.msecs ??= -Infinity;\n    state.nsecs ??= 0;\n    if (now === state.msecs) {\n        state.nsecs++;\n        if (state.nsecs >= 10000) {\n            state.node = undefined;\n            state.nsecs = 0;\n        }\n    }\n    else if (now > state.msecs) {\n        state.nsecs = 0;\n    }\n    else if (now < state.msecs) {\n        state.node = undefined;\n    }\n    if (!state.node) {\n        state.node = rnds.slice(10, 16);\n        state.node[0] |= 0x01;\n        state.clockseq = ((rnds[8] << 8) | rnds[9]) & 0x3fff;\n    }\n    state.msecs = now;\n    return state;\n}\nexports.updateV1State = updateV1State;\nfunction v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    if (!buf) {\n        buf = new Uint8Array(16);\n        offset = 0;\n    }\n    else {\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n    }\n    msecs ??= Date.now();\n    nsecs ??= 0;\n    clockseq ??= ((rnds[8] << 8) | rnds[9]) & 0x3fff;\n    node ??= rnds.slice(10, 16);\n    msecs += 12219292800000;\n    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    buf[offset++] = (tl >>> 24) & 0xff;\n    buf[offset++] = (tl >>> 16) & 0xff;\n    buf[offset++] = (tl >>> 8) & 0xff;\n    buf[offset++] = tl & 0xff;\n    const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;\n    buf[offset++] = (tmh >>> 8) & 0xff;\n    buf[offset++] = tmh & 0xff;\n    buf[offset++] = ((tmh >>> 24) & 0xf) | 0x10;\n    buf[offset++] = (tmh >>> 16) & 0xff;\n    buf[offset++] = (clockseq >>> 8) | 0x80;\n    buf[offset++] = clockseq & 0xff;\n    for (let n = 0; n < 6; ++n) {\n        buf[offset++] = node[n];\n    }\n    return buf;\n}\nexports[\"default\"] = v1;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/v1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/v1ToV6.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/dist/cjs/v1ToV6.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst parse_js_1 = __webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/cjs/parse.js\");\nconst stringify_js_1 = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/cjs/stringify.js\");\nfunction v1ToV6(uuid) {\n    const v1Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;\n    const v6Bytes = _v1ToV6(v1Bytes);\n    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;\n}\nexports[\"default\"] = v1ToV6;\nfunction _v1ToV6(v1Bytes) {\n    return Uint8Array.of(((v1Bytes[6] & 0x0f) << 4) | ((v1Bytes[7] >> 4) & 0x0f), ((v1Bytes[7] & 0x0f) << 4) | ((v1Bytes[4] & 0xf0) >> 4), ((v1Bytes[4] & 0x0f) << 4) | ((v1Bytes[5] & 0xf0) >> 4), ((v1Bytes[5] & 0x0f) << 4) | ((v1Bytes[0] & 0xf0) >> 4), ((v1Bytes[0] & 0x0f) << 4) | ((v1Bytes[1] & 0xf0) >> 4), ((v1Bytes[1] & 0x0f) << 4) | ((v1Bytes[2] & 0xf0) >> 4), 0x60 | (v1Bytes[2] & 0x0f), v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/v1ToV6.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/v3.js":
/*!******************************************!*\
  !*** ./node_modules/uuid/dist/cjs/v3.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.URL = exports.DNS = void 0;\nconst md5_js_1 = __webpack_require__(/*! ./md5.js */ \"./node_modules/uuid/dist/cjs/md5.js\");\nconst v35_js_1 = __webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/cjs/v35.js\");\nvar v35_js_2 = __webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/cjs/v35.js\");\nObject.defineProperty(exports, \"DNS\", ({ enumerable: true, get: function () { return v35_js_2.DNS; } }));\nObject.defineProperty(exports, \"URL\", ({ enumerable: true, get: function () { return v35_js_2.URL; } }));\nfunction v3(value, namespace, buf, offset) {\n    return (0, v35_js_1.default)(0x30, md5_js_1.default, value, namespace, buf, offset);\n}\nv3.DNS = v35_js_1.DNS;\nv3.URL = v35_js_1.URL;\nexports[\"default\"] = v3;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/v3.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/v35.js":
/*!*******************************************!*\
  !*** ./node_modules/uuid/dist/cjs/v35.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.URL = exports.DNS = exports.stringToBytes = void 0;\nconst parse_js_1 = __webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/cjs/parse.js\");\nconst stringify_js_1 = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/cjs/stringify.js\");\nfunction stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; ++i) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}\nexports.stringToBytes = stringToBytes;\nexports.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(version, hash, value, namespace, buf, offset) {\n    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;\n    const namespaceBytes = typeof namespace === 'string' ? (0, parse_js_1.default)(namespace) : namespace;\n    if (typeof namespace === 'string') {\n        namespace = (0, parse_js_1.default)(namespace);\n    }\n    if (namespace?.length !== 16) {\n        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n    let bytes = new Uint8Array(16 + valueBytes.length);\n    bytes.set(namespaceBytes);\n    bytes.set(valueBytes, namespaceBytes.length);\n    bytes = hash(bytes);\n    bytes[6] = (bytes[6] & 0x0f) | version;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return (0, stringify_js_1.unsafeStringify)(bytes);\n}\nexports[\"default\"] = v35;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/v35.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/v4.js":
/*!******************************************!*\
  !*** ./node_modules/uuid/dist/cjs/v4.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst native_js_1 = __webpack_require__(/*! ./native.js */ \"./node_modules/uuid/dist/cjs/native.js\");\nconst rng_js_1 = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/cjs/rng.js\");\nconst stringify_js_1 = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/cjs/stringify.js\");\nfunction v4(options, buf, offset) {\n    if (native_js_1.default.randomUUID && !buf && !options) {\n        return native_js_1.default.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? (0, rng_js_1.default)();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return (0, stringify_js_1.unsafeStringify)(rnds);\n}\nexports[\"default\"] = v4;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/v5.js":
/*!******************************************!*\
  !*** ./node_modules/uuid/dist/cjs/v5.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.URL = exports.DNS = void 0;\nconst sha1_js_1 = __webpack_require__(/*! ./sha1.js */ \"./node_modules/uuid/dist/cjs/sha1.js\");\nconst v35_js_1 = __webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/cjs/v35.js\");\nvar v35_js_2 = __webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/cjs/v35.js\");\nObject.defineProperty(exports, \"DNS\", ({ enumerable: true, get: function () { return v35_js_2.DNS; } }));\nObject.defineProperty(exports, \"URL\", ({ enumerable: true, get: function () { return v35_js_2.URL; } }));\nfunction v5(value, namespace, buf, offset) {\n    return (0, v35_js_1.default)(0x50, sha1_js_1.default, value, namespace, buf, offset);\n}\nv5.DNS = v35_js_1.DNS;\nv5.URL = v35_js_1.URL;\nexports[\"default\"] = v5;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/v5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/v6.js":
/*!******************************************!*\
  !*** ./node_modules/uuid/dist/cjs/v6.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst stringify_js_1 = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/cjs/stringify.js\");\nconst v1_js_1 = __webpack_require__(/*! ./v1.js */ \"./node_modules/uuid/dist/cjs/v1.js\");\nconst v1ToV6_js_1 = __webpack_require__(/*! ./v1ToV6.js */ \"./node_modules/uuid/dist/cjs/v1ToV6.js\");\nfunction v6(options, buf, offset) {\n    options ??= {};\n    offset ??= 0;\n    let bytes = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));\n    bytes = (0, v1ToV6_js_1.default)(bytes);\n    if (buf) {\n        for (let i = 0; i < 16; i++) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return (0, stringify_js_1.unsafeStringify)(bytes);\n}\nexports[\"default\"] = v6;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/v6.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/v6ToV1.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/dist/cjs/v6ToV1.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst parse_js_1 = __webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/cjs/parse.js\");\nconst stringify_js_1 = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/cjs/stringify.js\");\nfunction v6ToV1(uuid) {\n    const v6Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;\n    const v1Bytes = _v6ToV1(v6Bytes);\n    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;\n}\nexports[\"default\"] = v6ToV1;\nfunction _v6ToV1(v6Bytes) {\n    return Uint8Array.of(((v6Bytes[3] & 0x0f) << 4) | ((v6Bytes[4] >> 4) & 0x0f), ((v6Bytes[4] & 0x0f) << 4) | ((v6Bytes[5] & 0xf0) >> 4), ((v6Bytes[5] & 0x0f) << 4) | (v6Bytes[6] & 0x0f), v6Bytes[7], ((v6Bytes[1] & 0x0f) << 4) | ((v6Bytes[2] & 0xf0) >> 4), ((v6Bytes[2] & 0x0f) << 4) | ((v6Bytes[3] & 0xf0) >> 4), 0x10 | ((v6Bytes[0] & 0xf0) >> 4), ((v6Bytes[0] & 0x0f) << 4) | ((v6Bytes[1] & 0xf0) >> 4), v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/v6ToV1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/v7.js":
/*!******************************************!*\
  !*** ./node_modules/uuid/dist/cjs/v7.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.updateV7State = void 0;\nconst rng_js_1 = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/cjs/rng.js\");\nconst stringify_js_1 = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/cjs/stringify.js\");\nconst _state = {};\nfunction v7(options, buf, offset) {\n    let bytes;\n    if (options) {\n        bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);\n    }\n    else {\n        const now = Date.now();\n        const rnds = (0, rng_js_1.default)();\n        updateV7State(_state, now, rnds);\n        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);\n    }\n    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);\n}\nfunction updateV7State(state, now, rnds) {\n    state.msecs ??= -Infinity;\n    state.seq ??= 0;\n    if (now > state.msecs) {\n        state.seq = (rnds[6] << 23) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];\n        state.msecs = now;\n    }\n    else {\n        state.seq = (state.seq + 1) | 0;\n        if (state.seq === 0) {\n            state.msecs++;\n        }\n    }\n    return state;\n}\nexports.updateV7State = updateV7State;\nfunction v7Bytes(rnds, msecs, seq, buf, offset = 0) {\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    if (!buf) {\n        buf = new Uint8Array(16);\n        offset = 0;\n    }\n    else {\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n    }\n    msecs ??= Date.now();\n    seq ??= ((rnds[6] * 0x7f) << 24) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];\n    buf[offset++] = (msecs / 0x10000000000) & 0xff;\n    buf[offset++] = (msecs / 0x100000000) & 0xff;\n    buf[offset++] = (msecs / 0x1000000) & 0xff;\n    buf[offset++] = (msecs / 0x10000) & 0xff;\n    buf[offset++] = (msecs / 0x100) & 0xff;\n    buf[offset++] = msecs & 0xff;\n    buf[offset++] = 0x70 | ((seq >>> 28) & 0x0f);\n    buf[offset++] = (seq >>> 20) & 0xff;\n    buf[offset++] = 0x80 | ((seq >>> 14) & 0x3f);\n    buf[offset++] = (seq >>> 6) & 0xff;\n    buf[offset++] = ((seq << 2) & 0xff) | (rnds[10] & 0x03);\n    buf[offset++] = rnds[11];\n    buf[offset++] = rnds[12];\n    buf[offset++] = rnds[13];\n    buf[offset++] = rnds[14];\n    buf[offset++] = rnds[15];\n    return buf;\n}\nexports[\"default\"] = v7;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/v7.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/validate.js":
/*!************************************************!*\
  !*** ./node_modules/uuid/dist/cjs/validate.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst regex_js_1 = __webpack_require__(/*! ./regex.js */ \"./node_modules/uuid/dist/cjs/regex.js\");\nfunction validate(uuid) {\n    return typeof uuid === 'string' && regex_js_1.default.test(uuid);\n}\nexports[\"default\"] = validate;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/validate.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/cjs/version.js":
/*!***********************************************!*\
  !*** ./node_modules/uuid/dist/cjs/version.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst validate_js_1 = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/cjs/validate.js\");\nfunction version(uuid) {\n    if (!(0, validate_js_1.default)(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    return parseInt(uuid.slice(14, 15), 16);\n}\nexports[\"default\"] = version;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./node_modules/uuid/dist/cjs/version.js?");

/***/ }),

/***/ "./src/main sync recursive":
/*!************************!*\
  !*** ./src/main/ sync ***!
  \************************/
/***/ ((module) => {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src/main sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://pqcbenchgui4/./src/main/_sync?");

/***/ }),

/***/ "./src/main/JobSchedulerService.ts":
/*!*****************************************!*\
  !*** ./src/main/JobSchedulerService.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.jobSchedulerService = exports.JobSchedulerService = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/cjs/index.js\");\nconst benchmarkManager_1 = __webpack_require__(/*! ./benchmarkManager */ \"./src/main/benchmarkManager.ts\");\nconst lowdbService_1 = __webpack_require__(/*! ./db/lowdbService */ \"./src/main/db/lowdbService.ts\");\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\n/**\n * Service that manages job scheduling and execution\n */\nclass JobSchedulerService {\n    constructor() {\n        this.jobQueue = [];\n        this.isProcessing = false;\n        this.mainWindow = null;\n        this.scheduleCheckInterval = null;\n        console.log('[JobSchedulerService] Initializing job scheduler service');\n        this.startScheduleChecker();\n    }\n    /**\n     * Start the schedule checker that periodically checks for scheduled jobs\n     */\n    startScheduleChecker() {\n        // Check every 30 seconds for scheduled jobs\n        this.scheduleCheckInterval = setInterval(() => {\n            console.log('[JobSchedulerService] Checking for scheduled jobs');\n            this.processQueue();\n        }, 30000); // 30 seconds\n    }\n    /**\n     * Stop the schedule checker when the app is closing\n     */\n    stopScheduleChecker() {\n        if (this.scheduleCheckInterval) {\n            clearInterval(this.scheduleCheckInterval);\n            this.scheduleCheckInterval = null;\n        }\n    }\n    /**\n     * Set the main window reference to enable IPC communication\n     */\n    setMainWindow(window) {\n        this.mainWindow = window;\n    }\n    /**\n     * Add a new job to the queue and start processing if not already in progress\n     */\n    addJob(jobDefinition) {\n        // Create a new job with generated ID and timestamps\n        let newJob;\n        if (jobDefinition.type === 'benchmark') {\n            // Handle benchmark job\n            const benchmarkDef = jobDefinition;\n            newJob = {\n                ...benchmarkDef,\n                id: (0, uuid_1.v4)(),\n                status: 'pending',\n                createdAt: new Date(),\n                numberOfRuns: benchmarkDef.numberOfRuns || 1,\n                runCount: 0,\n            };\n        }\n        else {\n            // Handle quantum job\n            const quantumDef = jobDefinition;\n            newJob = {\n                ...quantumDef,\n                id: (0, uuid_1.v4)(),\n                status: 'pending',\n                createdAt: new Date(),\n                numberOfRuns: quantumDef.numberOfRuns || 1,\n                runCount: 0,\n            };\n        }\n        // Add job to queue\n        this.jobQueue.push(newJob);\n        // Send update to renderer\n        this.sendJobQueueUpdate();\n        // Start processing the queue if not already processing\n        this.processQueue();\n        return newJob;\n    }\n    /**\n     * Process the next pending job in the queue\n     */\n    async processQueue() {\n        // If already processing or no pending jobs, return\n        if (this.isProcessing || !this.getNextPendingJob()) {\n            return;\n        }\n        // Mark as processing\n        this.isProcessing = true;\n        // Get the next pending job\n        const job = this.getNextPendingJob();\n        if (!job) {\n            this.isProcessing = false;\n            return;\n        }\n        try {\n            // Update job status to running\n            job.status = 'running';\n            job.startedAt = new Date();\n            job.runCount = 0;\n            // Send update to renderer\n            this.sendJobQueueUpdate();\n            // Execute job based on type\n            if (job.type === 'benchmark') {\n                await this.executeBenchmarkJob(job);\n            }\n            else if (job.type === 'quantum') {\n                await this.executeQuantumJob(job);\n            }\n            // Mark job as completed\n            job.status = 'completed';\n            job.completedAt = new Date();\n        }\n        catch (error) {\n            // Mark job as failed\n            job.status = 'failed';\n            job.completedAt = new Date();\n            job.error = error.message || 'Unknown error occurred';\n            console.error(`[JobSchedulerService] Job ${job.id} failed:`, error);\n        }\n        // Send final update\n        this.sendJobQueueUpdate();\n        // Mark as not processing\n        this.isProcessing = false;\n        // Process next job\n        this.processQueue();\n    }\n    /**\n     * Execute a benchmark job\n     */\n    async executeBenchmarkJob(job) {\n        // Execute the job numberOfRuns times\n        for (let i = 0; i < job.numberOfRuns; i++) {\n            // Update run count\n            job.runCount = i + 1;\n            this.sendJobQueueUpdate();\n            // Skip if job was cancelled\n            if (job.status === 'cancelled') {\n                break;\n            }\n            try {\n                // Create params for benchmarkManager\n                const params = {\n                    algorithm: job.algorithm,\n                    securityParam: job.securityParameter,\n                    iterations: job.iterations,\n                };\n                // Execute benchmark\n                const result = await benchmarkManager_1.benchmarkManager.runBenchmark(params);\n                // Store the result\n                if (!job.result) {\n                    job.result = [];\n                }\n                job.result.push(result);\n                // Send update\n                this.sendJobQueueUpdate();\n            }\n            catch (error) {\n                // If any run fails, mark the entire job as failed and stop\n                throw error;\n            }\n        }\n    }\n    /**\n     * Execute a quantum job\n     */\n    async executeQuantumJob(job) {\n        // Execute the job numberOfRuns times\n        for (let i = 0; i < job.numberOfRuns; i++) {\n            // Update run count\n            job.runCount = i + 1;\n            this.sendJobQueueUpdate();\n            // Skip if job was cancelled\n            if (job.status === 'cancelled') {\n                break;\n            }\n            try {\n                let result;\n                if (job.algorithm === 'shor') {\n                    // Run Shor's algorithm\n                    result = await this.runQuantumWorkload(job.apiToken || '', job.shotCount, job.target === 'real_hardware', job.plotTheme || 'dark');\n                }\n                else if (job.algorithm === 'grover') {\n                    // Run Grover's algorithm\n                    result = await this.runGroverSearch(job.apiToken || '', job.markedStates || '101', job.shotCount, job.target === 'real_hardware', job.plotTheme || 'dark');\n                }\n                else {\n                    throw new Error(`Unknown quantum algorithm: ${job.algorithm}`);\n                }\n                // Store the result\n                if (!job.result) {\n                    job.result = [];\n                }\n                job.result.push(result);\n                // Send update\n                this.sendJobQueueUpdate();\n            }\n            catch (error) {\n                // If any run fails, mark the entire job as failed and stop\n                throw error;\n            }\n        }\n    }\n    /**\n     * Get the next pending job in the queue that is ready to run\n     * (not scheduled for a future time)\n     */\n    getNextPendingJob() {\n        const now = Date.now();\n        return this.jobQueue.find((job) => {\n            // Job must be pending\n            if (job.status !== 'pending')\n                return false;\n            // Check if job has a scheduled time in the future\n            if (job.scheduledTime && job.scheduledTime > now) {\n                return false;\n            }\n            // Job is pending and either has no scheduledTime or scheduledTime is in the past\n            return true;\n        });\n    }\n    /**\n     * Get the current state of the job queue\n     */\n    getQueueState() {\n        return [...this.jobQueue];\n    }\n    /**\n     * Cancel a pending job\n     */\n    cancelJob(jobId) {\n        const jobIndex = this.jobQueue.findIndex((job) => job.id === jobId);\n        if (jobIndex === -1) {\n            return false;\n        }\n        const job = this.jobQueue[jobIndex];\n        if (job.status === 'pending') {\n            job.status = 'cancelled';\n            this.sendJobQueueUpdate();\n            return true;\n        }\n        else if (job.status === 'running') {\n            // For running jobs, we can't cancel them directly yet\n            // In the future, we could implement cancellation for running processes\n            return false;\n        }\n        return false;\n    }\n    /**\n     * Remove a job from the queue\n     */\n    removeJob(jobId) {\n        const initialLength = this.jobQueue.length;\n        this.jobQueue = this.jobQueue.filter((job) => job.id !== jobId);\n        if (this.jobQueue.length !== initialLength) {\n            this.sendJobQueueUpdate();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Send a job queue update to the renderer process\n     */\n    sendJobQueueUpdate() {\n        if (this.mainWindow && !this.mainWindow.isDestroyed()) {\n            this.mainWindow.webContents.send('job-queue-update', this.getQueueState());\n        }\n    }\n    /**\n     * Implementation of runQuantumWorkload\n     */\n    async runQuantumWorkload(apiToken, shots, runOnHardware, plotTheme) {\n        console.log('[JobSchedulerService] Starting quantum Shor workload execution...');\n        // Generate unique filenames for outputs using timestamp and random ID\n        const timestamp = Date.now();\n        const randomId = Math.random().toString(36).substring(2, 10);\n        const userDataPath = electron_1.app.getPath('userData');\n        const outputPath = path_1.default.join(userDataPath, 'quantum_outputs');\n        // Ensure the output directory exists\n        if (!fs_1.default.existsSync(outputPath)) {\n            fs_1.default.mkdirSync(outputPath, { recursive: true });\n        }\n        // Generate paths for output files\n        const plotFilePath = path_1.default.join(outputPath, `plot_${timestamp}_${randomId}.png`);\n        const jsonFilePath = path_1.default.join(outputPath, `result_${timestamp}_${randomId}.json`);\n        // Create a run record in the database\n        const runId = await lowdbService_1.lowdbService.createRun('Quantum_Shor', 'Shor', 'N=15', // Fixed for now\n        shots);\n        // Update run status to running\n        await lowdbService_1.lowdbService.updateRunStatus(runId, 'running');\n        // Determine the path to the Python script\n        const isDevelopment = \"development\" === 'development';\n        const projectRoot = process.cwd();\n        // In development, use the script in the project directory\n        // In production, the script should be in resources/quantum\n        let scriptPath = '';\n        if (isDevelopment) {\n            scriptPath = path_1.default.join(projectRoot, 'quantum', 'shor_n15.py');\n        }\n        else {\n            // In production, resources folder contains our extra resources\n            const resourcesPath = path_1.default.join(process.resourcesPath || electron_1.app.getAppPath(), 'resources');\n            scriptPath = path_1.default.join(resourcesPath, 'quantum', 'shor_n15.py');\n        }\n        // Verify the script exists\n        if (!fs_1.default.existsSync(scriptPath)) {\n            console.error(`[JobSchedulerService] ERROR: Script not found at ${scriptPath}`);\n            // Update run status to failed\n            await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', `Python script not found at ${scriptPath}`);\n            return {\n                status: 'error',\n                error: `Python script not found at ${scriptPath}`,\n                logs: [`ERROR: Python script not found at ${scriptPath}`],\n            };\n        }\n        // Determine the Python executable path from virtual environment\n        let pythonExecutable = 'python'; // Default fallback\n        const venvPythonPath = path_1.default.join(projectRoot, '.venv', 'Scripts', 'python.exe'); // Windows path\n        // Check if the venv Python executable exists\n        if (fs_1.default.existsSync(venvPythonPath)) {\n            pythonExecutable = venvPythonPath;\n            console.log(`[JobSchedulerService] Using Python from virtual environment: ${pythonExecutable}`);\n        }\n        else {\n            console.warn(`[JobSchedulerService] Virtual environment Python not found at ${venvPythonPath}, falling back to system Python`);\n        }\n        // Build command arguments\n        const args = [\n            '--api_token',\n            apiToken,\n            '--shots',\n            shots.toString(),\n            '--plot_file',\n            plotFilePath,\n            '--plot_theme',\n            plotTheme,\n            '--output_json',\n            jsonFilePath,\n        ];\n        // Add run_on_hardware flag if true\n        if (runOnHardware) {\n            args.push('--run_on_hardware');\n        }\n        // Store logs\n        const logs = [];\n        console.log(`[JobSchedulerService] Executing Python script: ${pythonExecutable} ${scriptPath} ${args.join(' ')}`);\n        // Execute the script using spawn to capture real-time output\n        return new Promise((resolve, reject) => {\n            // When using the full path to python.exe, we need to pass the script path as the first argument\n            const pythonProcess = (0, child_process_1.spawn)(pythonExecutable, [scriptPath, ...args]);\n            // Capture stderr output for logs (script logs to stderr)\n            pythonProcess.stderr.on('data', (data) => {\n                const logLines = data.toString().split('\\n').filter(Boolean);\n                logs.push(...logLines);\n                console.log(`[JobSchedulerService] Log: ${data.toString().trim()}`);\n                // Send log update to renderer\n                if (this.mainWindow && !this.mainWindow.isDestroyed()) {\n                    this.mainWindow.webContents.send('quantum-log-update', data.toString().trim());\n                }\n            });\n            // Handle process completion\n            pythonProcess.on('close', async (code) => {\n                console.log(`[JobSchedulerService] Python process exited with code ${code}`);\n                // Check if output JSON exists and is readable\n                if (fs_1.default.existsSync(jsonFilePath)) {\n                    try {\n                        const resultData = JSON.parse(fs_1.default.readFileSync(jsonFilePath, 'utf8'));\n                        // Check if plot file exists\n                        const plotExists = fs_1.default.existsSync(plotFilePath);\n                        if (!plotExists) {\n                            logs.push('WARNING: Plot file was not generated.');\n                        }\n                        // Create result object\n                        const result = {\n                            status: code === 0 ? 'success' : 'error',\n                            exitCode: code,\n                            data: resultData,\n                            logs: logs,\n                            plotFilePath: plotExists ? plotFilePath : null,\n                            jsonFilePath: jsonFilePath,\n                        };\n                        // Store result in database if successful\n                        if (result.status === 'success') {\n                            await lowdbService_1.lowdbService.insertQuantumResult(runId, result);\n                            await lowdbService_1.lowdbService.updateRunStatus(runId, 'completed');\n                        }\n                        else {\n                            await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', 'Quantum execution failed with non-zero exit code');\n                        }\n                        resolve(result);\n                    }\n                    catch (err) {\n                        console.error('[JobSchedulerService] Error parsing result JSON:', err);\n                        // Update run status to failed\n                        await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', `Failed to parse result JSON: ${err.message}`);\n                        reject({\n                            status: 'error',\n                            error: 'Failed to parse result JSON',\n                            logs: logs,\n                            exitCode: code,\n                        });\n                    }\n                }\n                else {\n                    console.error('[JobSchedulerService] Result JSON file not found');\n                    // Update run status to failed\n                    await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', 'Result file not generated');\n                    reject({\n                        status: 'error',\n                        error: 'Result file not generated',\n                        logs: logs,\n                        exitCode: code,\n                    });\n                }\n            });\n            // Handle process errors\n            pythonProcess.on('error', async (err) => {\n                console.error('[JobSchedulerService] Failed to start Python process:', err);\n                // Update run status to failed\n                await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', `Failed to start Python process: ${err.message}`);\n                reject({\n                    status: 'error',\n                    error: `Failed to start Python process: ${err.message}`,\n                    logs: logs,\n                });\n            });\n        });\n    }\n    /**\n     * Implementation of runGroverSearch\n     */\n    async runGroverSearch(apiToken, markedStates, shots, runOnHardware, plotTheme) {\n        console.log('[JobSchedulerService] Starting quantum Grover search execution...');\n        // Generate unique filenames for outputs using timestamp and random ID\n        const timestamp = Date.now();\n        const randomId = Math.random().toString(36).substring(2, 10);\n        const userDataPath = electron_1.app.getPath('userData');\n        const outputPath = path_1.default.join(userDataPath, 'quantum_outputs');\n        // Ensure the output directory exists\n        if (!fs_1.default.existsSync(outputPath)) {\n            fs_1.default.mkdirSync(outputPath, { recursive: true });\n        }\n        // Generate paths for output files\n        const plotFilePath = path_1.default.join(outputPath, `grover_plot_${timestamp}_${randomId}.png`);\n        const jsonFilePath = path_1.default.join(outputPath, `grover_result_${timestamp}_${randomId}.json`);\n        // Create a run record in the database\n        const runId = await lowdbService_1.lowdbService.createRun('Quantum_Grover', 'Grover', markedStates, // Use markedStates as securityParam\n        shots);\n        // Update run status to running\n        await lowdbService_1.lowdbService.updateRunStatus(runId, 'running');\n        // Determine the path to the Python script\n        const isDevelopment = \"development\" === 'development';\n        const projectRoot = process.cwd();\n        // In development, use the script in the project directory\n        // In production, the script should be in resources/quantum\n        let scriptPath = '';\n        if (isDevelopment) {\n            scriptPath = path_1.default.join(projectRoot, 'quantum', 'grover_search.py');\n        }\n        else {\n            // In production, resources folder contains our extra resources\n            const resourcesPath = path_1.default.join(process.resourcesPath || electron_1.app.getAppPath(), 'resources');\n            scriptPath = path_1.default.join(resourcesPath, 'quantum', 'grover_search.py');\n        }\n        // Verify the script exists\n        if (!fs_1.default.existsSync(scriptPath)) {\n            console.error(`[JobSchedulerService] ERROR: Script not found at ${scriptPath}`);\n            // Update run status to failed\n            await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', `Python script not found at ${scriptPath}`);\n            return {\n                status: 'error',\n                error: `Python script not found at ${scriptPath}`,\n                logs: [`ERROR: Python script not found at ${scriptPath}`],\n            };\n        }\n        // Determine the Python executable path from virtual environment\n        let pythonExecutable = 'python'; // Default fallback\n        const venvPythonPath = path_1.default.join(projectRoot, '.venv', 'Scripts', 'python.exe'); // Windows path\n        // Check if the venv Python executable exists\n        if (fs_1.default.existsSync(venvPythonPath)) {\n            pythonExecutable = venvPythonPath;\n            console.log(`[JobSchedulerService] Using Python from virtual environment: ${pythonExecutable}`);\n        }\n        else {\n            console.warn(`[JobSchedulerService] Virtual environment Python not found at ${venvPythonPath}, falling back to system Python`);\n        }\n        // Build command arguments\n        const args = [\n            '--api_token',\n            apiToken,\n            '--marked_states',\n            markedStates,\n            '--shots',\n            shots.toString(),\n            '--plot_file',\n            plotFilePath,\n            '--plot_theme',\n            plotTheme,\n            '--output_json',\n            jsonFilePath,\n        ];\n        // Add run_on_hardware flag if true\n        if (runOnHardware) {\n            args.push('--run_on_hardware');\n        }\n        // Store logs\n        const logs = [];\n        console.log(`[JobSchedulerService] Executing Python script: ${pythonExecutable} ${scriptPath} ${args.join(' ')}`);\n        // Execute the script using spawn to capture real-time output\n        return new Promise((resolve, reject) => {\n            // When using the full path to python.exe, we need to pass the script path as the first argument\n            const pythonProcess = (0, child_process_1.spawn)(pythonExecutable, [scriptPath, ...args]);\n            // Capture stderr output for logs (script logs to stderr)\n            pythonProcess.stderr.on('data', (data) => {\n                const logLines = data.toString().split('\\n').filter(Boolean);\n                logs.push(...logLines);\n                console.log(`[JobSchedulerService] Log: ${data.toString().trim()}`);\n                // Send log update to renderer\n                if (this.mainWindow && !this.mainWindow.isDestroyed()) {\n                    this.mainWindow.webContents.send('quantum-log-update', data.toString().trim());\n                }\n            });\n            // Handle process completion\n            pythonProcess.on('close', async (code) => {\n                console.log(`[JobSchedulerService] Python process exited with code ${code}`);\n                // Check if output JSON exists and is readable\n                if (fs_1.default.existsSync(jsonFilePath)) {\n                    try {\n                        const resultData = JSON.parse(fs_1.default.readFileSync(jsonFilePath, 'utf8'));\n                        // Check if plot file exists\n                        const plotExists = fs_1.default.existsSync(plotFilePath);\n                        if (!plotExists) {\n                            logs.push('WARNING: Plot file was not generated.');\n                        }\n                        // Create result object\n                        const result = {\n                            status: code === 0 ? 'success' : 'error',\n                            exitCode: code,\n                            data: resultData,\n                            logs: logs,\n                            plotFilePath: plotExists ? plotFilePath : null,\n                            jsonFilePath: jsonFilePath,\n                            input_marked_states: [markedStates],\n                        };\n                        // Store result in database if successful\n                        if (result.status === 'success') {\n                            await lowdbService_1.lowdbService.insertQuantumResult(runId, result);\n                            await lowdbService_1.lowdbService.updateRunStatus(runId, 'completed');\n                        }\n                        else {\n                            await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', 'Quantum execution failed with non-zero exit code');\n                        }\n                        resolve(result);\n                    }\n                    catch (err) {\n                        console.error('[JobSchedulerService] Error parsing result JSON:', err);\n                        // Update run status to failed\n                        await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', `Failed to parse result JSON: ${err.message}`);\n                        reject({\n                            status: 'error',\n                            error: 'Failed to parse result JSON',\n                            logs: logs,\n                            exitCode: code,\n                        });\n                    }\n                }\n                else {\n                    console.error('[JobSchedulerService] Result JSON file not found');\n                    // Update run status to failed\n                    await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', 'Result file not generated');\n                    reject({\n                        status: 'error',\n                        error: 'Result file not generated',\n                        logs: logs,\n                        exitCode: code,\n                    });\n                }\n            });\n            // Handle process errors\n            pythonProcess.on('error', async (err) => {\n                console.error('[JobSchedulerService] Failed to start Python process:', err);\n                // Update run status to failed\n                await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', `Failed to start Python process: ${err.message}`);\n                reject({\n                    status: 'error',\n                    error: `Failed to start Python process: ${err.message}`,\n                    logs: logs,\n                });\n            });\n        });\n    }\n}\nexports.JobSchedulerService = JobSchedulerService;\n// Create and export singleton instance\nexports.jobSchedulerService = new JobSchedulerService();\n\n\n//# sourceURL=webpack://pqcbenchgui4/./src/main/JobSchedulerService.ts?");

/***/ }),

/***/ "./src/main/benchmarkManager.ts":
/*!**************************************!*\
  !*** ./src/main/benchmarkManager.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.benchmarkManager = void 0;\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/cjs/index.js\");\nconst lowdbService_1 = __webpack_require__(/*! ./db/lowdbService */ \"./src/main/db/lowdbService.ts\");\nclass BenchmarkManager {\n    constructor() {\n        this.activeProcesses = new Map();\n        this.executablesPath = 'C:\\\\Users\\\\brand\\\\executables';\n        this.progressCallback = null;\n    }\n    // Set up progress callback\n    onProgress(callback) {\n        this.progressCallback = callback;\n    }\n    async runBenchmark(params) {\n        // Create a run record in the database\n        const runId = await lowdbService_1.lowdbService.createRun('PQC_Classical', params.algorithm, params.securityParam, params.iterations);\n        // Update run status to running\n        await lowdbService_1.lowdbService.updateRunStatus(runId, 'running');\n        const benchmarkId = (0, uuid_1.v4)();\n        const executablePath = path_1.default.join(this.executablesPath, `benchmark_${params.algorithm}.exe`);\n        // Build args based on algorithm\n        const args = [];\n        // Add iterations parameter with required format: --iterations=VALUE\n        if (params.iterations) {\n            args.push(`--iterations=${params.iterations}`);\n        }\n        // Add security parameter (always as positional argument)\n        args.push(params.securityParam);\n        return new Promise((resolve, reject) => {\n            const metrics = {};\n            // Store last progress data for each operation type as a fallback\n            const lastProgressData = {};\n            // Store additional metadata separately for result info\n            let resultMetadata = {};\n            const process = (0, child_process_1.spawn)(executablePath, args);\n            this.activeProcesses.set(benchmarkId, process);\n            // Handle process output - extract metrics\n            process.stdout.on('data', (data) => {\n                const output = data.toString();\n                const lines = output.split('\\n');\n                for (const line of lines) {\n                    // Try to parse JSON progress data\n                    try {\n                        if (line.trim().startsWith('{') && line.trim().endsWith('}')) {\n                            const progressData = JSON.parse(line.trim());\n                            // If this is progress data, send it via the callback and store it\n                            if (progressData.progress &&\n                                typeof progressData.progress === 'string' &&\n                                typeof progressData.iteration === 'number' &&\n                                typeof progressData.total === 'number') {\n                                // Store the last progress data for each operation type\n                                lastProgressData[progressData.progress] = progressData;\n                                // Send to renderer if callback exists\n                                if (this.progressCallback) {\n                                    this.progressCallback(progressData);\n                                }\n                            }\n                        }\n                    }\n                    catch (e) {\n                        // Not valid JSON, continue with normal parsing\n                    }\n                    // Pattern 1: Metric (unit): value\n                    let match = line.match(/(\\w+)\\s*\\((?:\\w+|ms|KB|MB)\\):\\s*([\\d.]+)/i);\n                    if (match) {\n                        const [, metric, value] = match;\n                        metrics[metric.toLowerCase()] = parseFloat(value);\n                        continue;\n                    }\n                    // Pattern 2: Metric: value ms\n                    match = line.match(/(\\w+):\\s*([\\d.]+)\\s*(ms|KB|MB)/i);\n                    if (match) {\n                        const [, metric, value, unit] = match;\n                        metrics[`${metric.toLowerCase()}_${unit.toLowerCase()}`] =\n                            parseFloat(value);\n                        continue;\n                    }\n                    // Pattern 3: Metric = value\n                    match = line.match(/(\\w+)\\s*=\\s*([\\d.]+)/i);\n                    if (match) {\n                        const [, metric, value] = match;\n                        metrics[metric.toLowerCase()] = parseFloat(value);\n                        continue;\n                    }\n                    // Pattern 4: Memory metrics in KB/MB format\n                    match = line.match(/(\\w+)\\s*memory\\s*(?:\\w*)\\s*[=:]\\s*([\\d.]+)\\s*(KB|MB)/i);\n                    if (match) {\n                        const [, metricType, value, unit] = match;\n                        const metricName = `${metricType.toLowerCase()}_mem_${unit.toLowerCase()}`;\n                        metrics[metricName] = parseFloat(value);\n                        continue;\n                    }\n                    // Pattern 5: Peak/Average memory formats\n                    match = line.match(/(peak|average|avg)\\s*memory\\s*[=:]\\s*([\\d.]+)\\s*(KB|MB)/i);\n                    if (match) {\n                        const [, metricType, value, unit] = match;\n                        const normMetricType = metricType.toLowerCase() === 'average'\n                            ? 'avg'\n                            : metricType.toLowerCase();\n                        const metricName = `mem_${normMetricType}_${unit.toLowerCase()}`;\n                        metrics[metricName] = parseFloat(value);\n                        continue;\n                    }\n                    // Pattern 6: Special case for encapsulation/decapsulation with various naming formats\n                    match = line.match(/(encapsulat(?:e|ion)|decapsulat(?:e|ion)):\\s*([\\d.]+)\\s*(ms|KB|MB)/i);\n                    if (match) {\n                        const [, metric, value, unit] = match;\n                        // Normalize to 'encaps' or 'decaps' for consistency\n                        const normalizedMetric = metric.toLowerCase().startsWith('encaps')\n                            ? 'encaps'\n                            : 'decaps';\n                        metrics[`${normalizedMetric}_${unit.toLowerCase()}`] =\n                            parseFloat(value);\n                        continue;\n                    }\n                    // Pattern 7: Extended case for \"Operation time\" format (e.g., \"Encapsulate time: X ms\")\n                    match = line.match(/(encapsulat(?:e|ion)|decapsulat(?:e|ion)|encrypt(?:ion)?|decrypt(?:ion)?)\\s+time:\\s*([\\d.]+)\\s*(ms|KB|MB)/i);\n                    if (match) {\n                        const [, metric, value, unit] = match;\n                        // Normalize to standard operation names\n                        let normalizedMetric = metric.toLowerCase();\n                        if (normalizedMetric.startsWith('encapsulat'))\n                            normalizedMetric = 'encaps';\n                        else if (normalizedMetric.startsWith('decapsulat'))\n                            normalizedMetric = 'decaps';\n                        else if (normalizedMetric.startsWith('encrypt'))\n                            normalizedMetric = 'encrypt';\n                        else if (normalizedMetric.startsWith('decrypt'))\n                            normalizedMetric = 'decrypt';\n                        metrics[`${normalizedMetric}_${unit.toLowerCase()}`] =\n                            parseFloat(value);\n                        continue;\n                    }\n                }\n            });\n            // Handle stderr output for better error reporting\n            let errorOutput = '';\n            process.stderr.on('data', (data) => {\n                errorOutput += data.toString();\n            });\n            process.on('error', async (error) => {\n                this.activeProcesses.delete(benchmarkId);\n                // Update run status to failed\n                await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', error.message || 'Unknown error occurred');\n                reject({\n                    id: benchmarkId,\n                    algorithm: params.algorithm,\n                    securityParam: params.securityParam,\n                    metrics: {},\n                    timestamp: new Date().toISOString(),\n                    status: 'failed',\n                    error: error.message || 'Unknown error occurred',\n                });\n            });\n            process.on('close', async (code) => {\n                this.activeProcesses.delete(benchmarkId);\n                // Check if we actually got any metrics\n                let hasMetrics = Object.keys(metrics).length > 0;\n                // Log the metrics we found for debugging\n                console.log(`Raw metrics collected for ${params.algorithm}:`, JSON.stringify(metrics, null, 2));\n                // Normalize metrics keys to handle various naming conventions\n                this.normalizeMetricsKeys(metrics);\n                // Log the normalized metrics\n                console.log(`Normalized metrics for ${params.algorithm}:`, JSON.stringify(metrics, null, 2));\n                // If no metrics were found through regex, use the metrics from progress data\n                if (!hasMetrics && Object.keys(lastProgressData).length > 0) {\n                    // Convert progress data to metrics\n                    Object.values(lastProgressData).forEach((data) => {\n                        if (data.progress) {\n                            // Add average time for this operation\n                            metrics[`${data.progress}_avg_ms`] = data.current_avg_ms;\n                            // Add min/max times\n                            metrics[`${data.progress}_min_ms`] = data.current_min_ms;\n                            metrics[`${data.progress}_max_ms`] = data.current_max_ms;\n                            // Add throughput\n                            metrics[`${data.progress}_ops_sec`] =\n                                data.current_throughput_ops_sec;\n                            // Add memory metrics if available\n                            if (data.current_mem_avg_kb !== undefined) {\n                                metrics[`${data.progress}_mem_avg_kb`] =\n                                    data.current_mem_avg_kb;\n                            }\n                            if (data.current_mem_peak_kb !== undefined) {\n                                metrics[`${data.progress}_mem_peak_kb`] =\n                                    data.current_mem_peak_kb;\n                            }\n                            // For algorithms that report 0 for memory metrics, estimate based on algorithm\n                            if ((data.current_mem_avg_kb === 0 ||\n                                data.current_mem_peak_kb === 0) &&\n                                (params.algorithm === 'dilithium' ||\n                                    params.algorithm === 'falcon' ||\n                                    params.algorithm === 'sphincs')) {\n                                // Rough estimates based on Dilithium specifications - adjust as needed\n                                const dilithiumMemoryEstimates = {\n                                    'Dilithium-2': { avg: 0.604, peak: 580 },\n                                    'Dilithium-3': { avg: 0.048, peak: 32 },\n                                    'Dilithium-5': { avg: 0.036, peak: 36 },\n                                };\n                                // Estimated memory values for Falcon variants\n                                const falconMemoryEstimates = {\n                                    'Falcon-512': { avg: 0.66, peak: 640 },\n                                    'Falcon-1024': { avg: 0.128, peak: 128 },\n                                    'Falcon-padded-512': { avg: 0.108, peak: 108 },\n                                    'Falcon-padded-1024': { avg: 0.084, peak: 84 },\n                                };\n                                // Estimated memory values for SPHINCS+ variants\n                                const sphincsMemoryEstimates = {\n                                    'SPHINCS+-SHA2-128f-simple': { avg: 0.01, peak: 1 },\n                                    'SPHINCS+-SHA2-128s-simple': { avg: 0.08, peak: 8 },\n                                    'SPHINCS+-SHA2-192f-simple': { avg: 0, peak: 0 },\n                                    'SPHINCS+-SHA2-192s-simple': { avg: 0.12, peak: 12 },\n                                    'SPHINCS+-SHA2-256f-simple': { avg: 0.12, peak: 12 },\n                                    'SPHINCS+-SHA2-256s-simple': { avg: 0.08, peak: 8 },\n                                    'SPHINCS+-SHAKE-128f-simple': { avg: 0.2, peak: 20 },\n                                    'SPHINCS+-SHAKE-128s-simple': { avg: 0.12, peak: 12 },\n                                    'SPHINCS+-SHAKE-192f-simple': { avg: 0, peak: 0 },\n                                    'SPHINCS+-SHAKE-192s-simple': { avg: 0, peak: 0 },\n                                    'SPHINCS+-SHAKE-256f-simple': { avg: 0.08, peak: 8 },\n                                    'SPHINCS+-SHAKE-256s-simple': { avg: 0, peak: 0 },\n                                };\n                                // Get the closest match to the parameter\n                                let estimate;\n                                if (params.algorithm === 'dilithium') {\n                                    const estimateKey = Object.keys(dilithiumMemoryEstimates).find((key) => params.securityParam.includes(key) ||\n                                        key.includes(params.securityParam));\n                                    if (estimateKey) {\n                                        estimate =\n                                            dilithiumMemoryEstimates[estimateKey];\n                                    }\n                                }\n                                else if (params.algorithm === 'falcon') {\n                                    const estimateKey = Object.keys(falconMemoryEstimates).find((key) => params.securityParam.includes(key) ||\n                                        key.includes(params.securityParam));\n                                    if (estimateKey) {\n                                        estimate =\n                                            falconMemoryEstimates[estimateKey];\n                                    }\n                                }\n                                else if (params.algorithm === 'sphincs') {\n                                    const estimateKey = Object.keys(sphincsMemoryEstimates).find((key) => params.securityParam.includes(key) ||\n                                        key.includes(params.securityParam));\n                                    if (estimateKey) {\n                                        estimate =\n                                            sphincsMemoryEstimates[estimateKey];\n                                    }\n                                }\n                                if (estimate) {\n                                    // Use operation-specific adjustments\n                                    if (data.progress === 'sign') {\n                                        if (params.algorithm === 'falcon') {\n                                            metrics[`${data.progress}_mem_avg_kb`] =\n                                                estimate.avg * 0.1; // Falcon sign uses less memory than keygen\n                                            metrics[`${data.progress}_mem_peak_kb`] =\n                                                estimate.peak * 0.1; // Approximate\n                                        }\n                                        else if (params.algorithm === 'sphincs') {\n                                            metrics[`${data.progress}_mem_avg_kb`] =\n                                                estimate.avg * 0.05; // SPHINCS+ sign memory estimate\n                                            metrics[`${data.progress}_mem_peak_kb`] =\n                                                estimate.peak * 0.05; // Approximate\n                                        }\n                                        else {\n                                            metrics[`${data.progress}_mem_avg_kb`] =\n                                                estimate.avg * 20; // Sign uses more memory for Dilithium\n                                            metrics[`${data.progress}_mem_peak_kb`] =\n                                                estimate.peak / 50; // Approximate\n                                        }\n                                    }\n                                    else if (data.progress === 'verify') {\n                                        metrics[`${data.progress}_mem_avg_kb`] = 0; // Minimal memory for verify\n                                        metrics[`${data.progress}_mem_peak_kb`] = 0; // Minimal memory for verify\n                                    }\n                                    else {\n                                        metrics[`${data.progress}_mem_avg_kb`] = estimate.avg;\n                                        metrics[`${data.progress}_mem_peak_kb`] = estimate.peak;\n                                    }\n                                }\n                            }\n                        }\n                    });\n                    // Check if we've added metrics from progress data\n                    hasMetrics = Object.keys(metrics).length > 0;\n                }\n                // For Dilithium: Ensure we have operation-specific metrics based on the provided output data\n                if ((params.algorithm === 'dilithium' ||\n                    params.algorithm === 'falcon' ||\n                    params.algorithm === 'sphincs') &&\n                    hasMetrics) {\n                    // Normalize metrics to ensure all operation types have entries\n                    // This helps with displaying the results properly\n                    const operations = ['keygen', 'sign', 'verify'];\n                    operations.forEach((op) => {\n                        // Check if we have metrics for this operation\n                        const hasOpMetrics = Object.keys(metrics).some((key) => key.startsWith(`${op}_`));\n                        // If no specific metrics exist for this operation but we have general metrics,\n                        // try to create them based on the simple metric format\n                        if (!hasOpMetrics && metrics[op] !== undefined) {\n                            metrics[`${op}_avg_ms`] = metrics[op];\n                            metrics[`${op}_min_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_max_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_ops_sec`] = 1000 / metrics[op]; // Approximate\n                        }\n                    });\n                }\n                // For McEliece: Ensure operation-specific metrics are properly normalized\n                if (params.algorithm === 'mceliece' && hasMetrics) {\n                    // Normalize metrics for each operation\n                    const operations = ['keygen', 'encaps', 'decaps'];\n                    operations.forEach((op) => {\n                        // Check if we have metrics for this operation\n                        const hasOpMetrics = Object.keys(metrics).some((key) => key.startsWith(`${op}_`));\n                        // If no specific metrics exist for this operation but we have general metrics,\n                        // try to create them based on the simple metric format\n                        if (!hasOpMetrics && metrics[op] !== undefined) {\n                            metrics[`${op}_avg_ms`] = metrics[op];\n                            metrics[`${op}_min_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_max_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_ops_sec`] = 1000 / metrics[op]; // Approximate\n                        }\n                        // If we have missing memory metrics, add zeros as placeholders\n                        if (metrics[`${op}_avg_ms`] !== undefined) {\n                            if (metrics[`${op}_mem_avg_kb`] === undefined) {\n                                metrics[`${op}_mem_avg_kb`] = 0;\n                            }\n                            if (metrics[`${op}_mem_peak_kb`] === undefined) {\n                                metrics[`${op}_mem_peak_kb`] = 0;\n                            }\n                        }\n                    });\n                }\n                // For AES: Ensure operation-specific metrics are properly normalized\n                if (params.algorithm === 'aes' && hasMetrics) {\n                    // Normalize metrics for each operation\n                    const operations = ['encrypt', 'decrypt'];\n                    operations.forEach((op) => {\n                        // Check if we have metrics for this operation\n                        const hasOpMetrics = Object.keys(metrics).some((key) => key.startsWith(`${op}_`));\n                        // If no specific metrics exist for this operation but we have general metrics,\n                        // try to create them based on the simple metric format\n                        if (!hasOpMetrics && metrics[op] !== undefined) {\n                            metrics[`${op}_avg_ms`] = metrics[op];\n                            metrics[`${op}_min_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_max_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_ops_sec`] = 1000 / metrics[op]; // Approximate\n                        }\n                        // If we have missing memory metrics, add zeros as placeholders\n                        if (metrics[`${op}_avg_ms`] !== undefined) {\n                            if (metrics[`${op}_mem_avg_kb`] === undefined) {\n                                metrics[`${op}_mem_avg_kb`] = 0;\n                            }\n                            if (metrics[`${op}_mem_peak_kb`] === undefined) {\n                                metrics[`${op}_mem_peak_kb`] = 0;\n                            }\n                        }\n                    });\n                    // Extract key_size from progress data if available\n                    // This is specific to AES benchmarks\n                    if (Object.keys(lastProgressData).length > 0) {\n                        const firstProgressKey = Object.keys(lastProgressData)[0];\n                        const firstProgressData = lastProgressData[firstProgressKey];\n                        if (firstProgressData && firstProgressData.key_size) {\n                            metrics['key_size'] = firstProgressData.key_size;\n                        }\n                    }\n                }\n                // For RSA: Ensure operation-specific metrics are properly normalized\n                if (params.algorithm === 'rsa' && hasMetrics) {\n                    // Normalize metrics for each operation\n                    const operations = ['keygen', 'encrypt', 'decrypt'];\n                    operations.forEach((op) => {\n                        // Check if we have metrics for this operation\n                        const hasOpMetrics = Object.keys(metrics).some((key) => key.startsWith(`${op}_`));\n                        // If no specific metrics exist for this operation but we have general metrics,\n                        // try to create them based on the simple metric format\n                        if (!hasOpMetrics && metrics[op] !== undefined) {\n                            metrics[`${op}_avg_ms`] = metrics[op];\n                            metrics[`${op}_min_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_max_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_ops_sec`] = 1000 / metrics[op]; // Approximate\n                        }\n                        // If we have missing memory metrics, add zeros as placeholders\n                        if (metrics[`${op}_avg_ms`] !== undefined) {\n                            if (metrics[`${op}_mem_avg_kb`] === undefined) {\n                                metrics[`${op}_mem_avg_kb`] = 0;\n                            }\n                            if (metrics[`${op}_mem_peak_kb`] === undefined) {\n                                metrics[`${op}_mem_peak_kb`] = 0;\n                            }\n                        }\n                    });\n                    // Extract key_size from progress data if available\n                    // This is specific to RSA benchmarks\n                    if (Object.keys(lastProgressData).length > 0) {\n                        const firstProgressKey = Object.keys(lastProgressData)[0];\n                        const firstProgressData = lastProgressData[firstProgressKey];\n                        if (firstProgressData && firstProgressData.key_size) {\n                            metrics['key_size'] = firstProgressData.key_size;\n                        }\n                    }\n                    // Extract key sizes if available in the metrics\n                    if (metrics['public_key_bytes'] !== undefined) {\n                        metrics['public_key_size'] = metrics['public_key_bytes'];\n                    }\n                    if (metrics['secret_key_bytes'] !== undefined) {\n                        metrics['secret_key_size'] = metrics['secret_key_bytes'];\n                    }\n                }\n                // For ECDH: Ensure operation-specific metrics are properly normalized\n                if (params.algorithm === 'ecdh' && hasMetrics) {\n                    // Normalize metrics for each operation\n                    const operations = ['keygen', 'shared_secret'];\n                    operations.forEach((op) => {\n                        // Check if we have metrics for this operation\n                        const hasOpMetrics = Object.keys(metrics).some((key) => key.startsWith(`${op}_`));\n                        // If no specific metrics exist for this operation but we have general metrics,\n                        // try to create them based on the simple metric format\n                        if (!hasOpMetrics && metrics[op] !== undefined) {\n                            metrics[`${op}_avg_ms`] = metrics[op];\n                            metrics[`${op}_min_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_max_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_ops_sec`] = 1000 / metrics[op]; // Approximate\n                        }\n                        // If we have missing memory metrics, add zeros as placeholders\n                        if (metrics[`${op}_avg_ms`] !== undefined) {\n                            if (metrics[`${op}_mem_avg_kb`] === undefined) {\n                                metrics[`${op}_mem_avg_kb`] = 0;\n                            }\n                            if (metrics[`${op}_mem_peak_kb`] === undefined) {\n                                metrics[`${op}_mem_peak_kb`] = 0;\n                            }\n                        }\n                    });\n                    // Extract curve information and key sizes from progress data\n                    if (Object.keys(lastProgressData).length > 0) {\n                        // Find the first progress data with curve information\n                        let curveData = null;\n                        for (const key of Object.keys(lastProgressData)) {\n                            const data = lastProgressData[key];\n                            if (data.curve) {\n                                curveData = data;\n                                break;\n                            }\n                        }\n                        if (curveData) {\n                            // Store curve name in metadata, not in metrics\n                            resultMetadata.curve = curveData.curve;\n                            // Store key and shared secret sizes if available\n                            if (curveData.public_key_bytes !== undefined) {\n                                metrics['public_key_bytes'] = Number(curveData.public_key_bytes);\n                            }\n                            if (curveData.secret_key_bytes !== undefined) {\n                                metrics['secret_key_bytes'] = Number(curveData.secret_key_bytes);\n                            }\n                            if (curveData.shared_secret_bytes !== undefined) {\n                                metrics['shared_secret_bytes'] = Number(curveData.shared_secret_bytes);\n                            }\n                        }\n                    }\n                }\n                // For ECDSA: Ensure operation-specific metrics are properly normalized\n                if (params.algorithm === 'ecdsa' && hasMetrics) {\n                    // Normalize metrics for each operation\n                    const operations = ['keygen', 'sign', 'verify'];\n                    operations.forEach((op) => {\n                        // Check if we have metrics for this operation\n                        const hasOpMetrics = Object.keys(metrics).some((key) => key.startsWith(`${op}_`));\n                        // If no specific metrics exist for this operation but we have general metrics,\n                        // try to create them based on the simple metric format\n                        if (!hasOpMetrics && metrics[op] !== undefined) {\n                            metrics[`${op}_avg_ms`] = metrics[op];\n                            metrics[`${op}_min_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_max_ms`] = metrics[op]; // Approximate\n                            metrics[`${op}_ops_sec`] = 1000 / metrics[op]; // Approximate\n                        }\n                        // If we have missing memory metrics, add zeros as placeholders\n                        if (metrics[`${op}_avg_ms`] !== undefined) {\n                            if (metrics[`${op}_mem_avg_kb`] === undefined) {\n                                metrics[`${op}_mem_avg_kb`] = 0;\n                            }\n                            if (metrics[`${op}_mem_peak_kb`] === undefined) {\n                                metrics[`${op}_mem_peak_kb`] = 0;\n                            }\n                        }\n                    });\n                    // Extract curve information and key sizes from progress data\n                    if (Object.keys(lastProgressData).length > 0) {\n                        // Find the first progress data with curve information\n                        let curveData = null;\n                        for (const key of Object.keys(lastProgressData)) {\n                            const data = lastProgressData[key];\n                            if (data.curve) {\n                                curveData = data;\n                                break;\n                            }\n                        }\n                        if (curveData) {\n                            // Store curve name in metadata, not in metrics\n                            resultMetadata.curve = curveData.curve;\n                            // Create a sizes object in the metadata\n                            resultMetadata.sizes = {\n                                public_key_bytes: curveData.public_key_bytes || 0,\n                                secret_key_bytes: curveData.secret_key_bytes || 0,\n                                signature_bytes: curveData.signature_bytes || 0,\n                            };\n                            // Also store key and signature sizes in metrics for consistency\n                            if (curveData.public_key_bytes !== undefined) {\n                                metrics['public_key_bytes'] = Number(curveData.public_key_bytes);\n                            }\n                            if (curveData.secret_key_bytes !== undefined) {\n                                metrics['secret_key_bytes'] = Number(curveData.secret_key_bytes);\n                            }\n                            if (curveData.signature_bytes !== undefined) {\n                                metrics['signature_bytes'] = Number(curveData.signature_bytes);\n                            }\n                        }\n                    }\n                }\n                if (code === 0 && hasMetrics) {\n                    // Create the benchmark result object\n                    const benchmarkData = {\n                        id: benchmarkId,\n                        algorithm: params.algorithm,\n                        securityParam: params.securityParam,\n                        metrics,\n                        timestamp: new Date().toISOString(),\n                        status: 'completed',\n                        resultMetadata,\n                        iterations: params.iterations,\n                    };\n                    // Format the data for LowDB\n                    const formattedResult = this.formatBenchmarkResultForLowDB(benchmarkData);\n                    try {\n                        // Save the results to LowDB\n                        await lowdbService_1.lowdbService.insertPqcClassicalResult(runId, formattedResult);\n                        // Update run status to completed\n                        await lowdbService_1.lowdbService.updateRunStatus(runId, 'completed');\n                        // Return the result\n                        resolve(benchmarkData);\n                    }\n                    catch (dbError) {\n                        console.error('Error saving benchmark to database:', dbError);\n                        resolve(benchmarkData); // Still return the result even if saving fails\n                    }\n                }\n                else {\n                    // On failure, update run status and reject with error\n                    const errorMessage = errorOutput ||\n                        (code !== 0\n                            ? `Process exited with code ${code}`\n                            : 'No metrics found in benchmark output');\n                    // Update run status to failed\n                    await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', errorMessage);\n                    reject({\n                        id: benchmarkId,\n                        algorithm: params.algorithm,\n                        securityParam: params.securityParam,\n                        metrics: hasMetrics ? metrics : {},\n                        timestamp: new Date().toISOString(),\n                        status: 'failed',\n                        error: errorMessage,\n                        resultMetadata,\n                    });\n                }\n            });\n        });\n    }\n    /**\n     * Format the benchmark result data into a format suitable for LowDB storage\n     * This will reorganize metrics into algorithm-specific structures\n     */\n    formatBenchmarkResultForLowDB(benchmarkData) {\n        const { algorithm, securityParam, metrics, resultMetadata, iterations } = benchmarkData;\n        // Common structure for all algorithms\n        const result = {\n            algorithm,\n            iterations,\n            results: [],\n        };\n        // Group metrics by operation type and format them\n        const formatMetricsForOperation = (operation) => {\n            // Normalize operation names to match what could be in the metrics\n            let metricsKeyOptions = [operation]; // Start with original (e.g., 'encaps')\n            // Add alternative naming conventions for encaps/decaps operations\n            if (operation === 'encaps') {\n                metricsKeyOptions = [\n                    ...metricsKeyOptions,\n                    'encapsulate',\n                    'encapsulation',\n                ];\n            }\n            else if (operation === 'decaps') {\n                metricsKeyOptions = [\n                    ...metricsKeyOptions,\n                    'decapsulate',\n                    'decapsulation',\n                ];\n            }\n            else if (operation === 'encrypt') {\n                metricsKeyOptions = [...metricsKeyOptions, 'encryption'];\n            }\n            else if (operation === 'decrypt') {\n                metricsKeyOptions = [...metricsKeyOptions, 'decryption'];\n            }\n            // Try all possible key variations for each metric\n            let min_ms = 0, max_ms = 0, avg_ms = 0, ops_per_sec = 0, mem_peak_kb = 0, mem_avg_kb = 0;\n            for (const key of metricsKeyOptions) {\n                min_ms = metrics[`${key}_min_ms`] || min_ms;\n                max_ms = metrics[`${key}_max_ms`] || max_ms;\n                avg_ms = metrics[`${key}_avg_ms`] || avg_ms;\n                ops_per_sec =\n                    metrics[`${key}_ops_sec`] ||\n                        metrics[`${key}_ops_per_sec`] ||\n                        ops_per_sec;\n                mem_peak_kb = metrics[`${key}_mem_peak_kb`] || mem_peak_kb;\n                mem_avg_kb = metrics[`${key}_mem_avg_kb`] || mem_avg_kb;\n            }\n            return {\n                min_ms,\n                max_ms,\n                avg_ms,\n                ops_per_sec,\n                mem_peak_kb,\n                mem_avg_kb,\n            };\n        };\n        // Create sizes object with relevant size information\n        const createSizesObject = () => {\n            const sizes = {};\n            if (metrics['public_key_bytes'] !== undefined) {\n                sizes.public_key_bytes = metrics['public_key_bytes'];\n            }\n            if (metrics['secret_key_bytes'] !== undefined) {\n                sizes.secret_key_bytes = metrics['secret_key_bytes'];\n            }\n            if (metrics['signature_bytes'] !== undefined) {\n                sizes.signature_bytes = metrics['signature_bytes'];\n            }\n            if (metrics['ciphertext_bytes'] !== undefined) {\n                sizes.ciphertext_bytes = metrics['ciphertext_bytes'];\n            }\n            if (metrics['shared_secret_bytes'] !== undefined) {\n                sizes.shared_secret_bytes = metrics['shared_secret_bytes'];\n            }\n            if (metrics['key_bytes'] !== undefined) {\n                sizes.key_bytes = metrics['key_bytes'];\n            }\n            if (metrics['iv_bytes'] !== undefined) {\n                sizes.iv_bytes = metrics['iv_bytes'];\n            }\n            // If resultMetadata contains sizes, merge them\n            if (resultMetadata?.sizes) {\n                Object.assign(sizes, resultMetadata.sizes);\n            }\n            return Object.keys(sizes).length > 0 ? sizes : undefined;\n        };\n        // Format based on algorithm type\n        switch (algorithm.toLowerCase()) {\n            case 'kyber':\n            case 'mceliece':\n                // KEM algorithms: keygen, encaps, decaps\n                result.results.push({\n                    algorithm: securityParam,\n                    sizes: createSizesObject(),\n                    keygen: formatMetricsForOperation('keygen'),\n                    encaps: formatMetricsForOperation('encaps'),\n                    decaps: formatMetricsForOperation('decaps'),\n                });\n                break;\n            case 'dilithium':\n            case 'falcon':\n            case 'sphincs':\n                // Signature algorithms: keygen, sign, verify\n                result.results.push({\n                    algorithm: securityParam,\n                    sizes: createSizesObject(),\n                    keygen: formatMetricsForOperation('keygen'),\n                    sign: formatMetricsForOperation('sign'),\n                    verify: formatMetricsForOperation('verify'),\n                });\n                break;\n            case 'aes':\n                // Symmetric encryption: encrypt, decrypt\n                result.results.push({\n                    algorithm: securityParam,\n                    key_size: metrics['key_size'] || parseInt(securityParam),\n                    key_bytes: metrics['key_size']\n                        ? metrics['key_size'] / 8\n                        : parseInt(securityParam) / 8,\n                    iv_bytes: metrics['iv_bytes'] || 12, // Default for AES-GCM\n                    ciphertext_bytes: metrics['ciphertext_bytes'] || 44, // Default approximation\n                    encryption: formatMetricsForOperation('encrypt'),\n                    decryption: formatMetricsForOperation('decrypt'),\n                });\n                break;\n            case 'rsa':\n                // RSA: keygen, encrypt, decrypt\n                result.results.push({\n                    algorithm: securityParam,\n                    key_size: metrics['key_size'] || parseInt(securityParam),\n                    sizes: createSizesObject(),\n                    keygen: formatMetricsForOperation('keygen'),\n                    encryption: formatMetricsForOperation('encrypt'),\n                    decryption: formatMetricsForOperation('decrypt'),\n                });\n                break;\n            case 'ecdh':\n                // ECDH: keygen, shared_secret\n                result.results.push({\n                    curve: resultMetadata?.curve || securityParam,\n                    sizes: createSizesObject(),\n                    keygen: formatMetricsForOperation('keygen'),\n                    shared_secret: formatMetricsForOperation('shared_secret'),\n                });\n                break;\n            case 'ecdsa':\n                // ECDSA: keygen, sign, verify\n                result.results.push({\n                    curve: resultMetadata?.curve || securityParam,\n                    sizes: createSizesObject(),\n                    keygen: formatMetricsForOperation('keygen'),\n                    sign: formatMetricsForOperation('sign'),\n                    verify: formatMetricsForOperation('verify'),\n                });\n                break;\n            default:\n                // Generic format for other algorithms\n                const algorithmResult = {\n                    parameter: securityParam,\n                };\n                // Add metrics for common operations if they exist\n                if (metrics['keygen_avg_ms'])\n                    algorithmResult.keygen = formatMetricsForOperation('keygen');\n                if (metrics['sign_avg_ms'])\n                    algorithmResult.sign = formatMetricsForOperation('sign');\n                if (metrics['verify_avg_ms'])\n                    algorithmResult.verify = formatMetricsForOperation('verify');\n                if (metrics['encaps_avg_ms'])\n                    algorithmResult.encaps = formatMetricsForOperation('encaps');\n                if (metrics['decaps_avg_ms'])\n                    algorithmResult.decaps = formatMetricsForOperation('decaps');\n                if (metrics['encrypt_avg_ms'])\n                    algorithmResult.encryption = formatMetricsForOperation('encrypt');\n                if (metrics['decrypt_avg_ms'])\n                    algorithmResult.decryption = formatMetricsForOperation('decrypt');\n                // Add sizes\n                const sizes = createSizesObject();\n                if (sizes) {\n                    algorithmResult.sizes = sizes;\n                }\n                result.results.push(algorithmResult);\n        }\n        return result;\n    }\n    async stopBenchmark(benchmarkId) {\n        const process = this.activeProcesses.get(benchmarkId);\n        if (process) {\n            process.kill();\n            this.activeProcesses.delete(benchmarkId);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Utility to normalize metrics keys for consistent naming\n     * This helps handle variations in how operations are named in benchmark output\n     */\n    normalizeMetricsKeys(metrics) {\n        const renamedMetrics = {};\n        // Create a map of operation name patterns\n        const operationMap = {\n            encapsulat: 'encaps',\n            decapsulat: 'decaps',\n            encryption: 'encrypt',\n            decryption: 'decrypt',\n        };\n        // Scan each metric key\n        for (const [key, value] of Object.entries(metrics)) {\n            let newKey = key;\n            // Check if key contains any of the patterns and replace with normalized version\n            for (const [pattern, replacement] of Object.entries(operationMap)) {\n                if (key.includes(pattern)) {\n                    // Replace the matched pattern with its normalized version\n                    newKey = key.replace(new RegExp(pattern, 'i'), replacement);\n                    break;\n                }\n            }\n            // Store with new key (might be the same as original if no replacement was made)\n            renamedMetrics[newKey] = value;\n        }\n        // Add all renamed metrics back to the original metrics object\n        for (const [key, value] of Object.entries(renamedMetrics)) {\n            metrics[key] = value;\n        }\n    }\n}\nexports.benchmarkManager = new BenchmarkManager();\n\n\n//# sourceURL=webpack://pqcbenchgui4/./src/main/benchmarkManager.ts?");

/***/ }),

/***/ "./src/main/dataset-manager.ts":
/*!*************************************!*\
  !*** ./src/main/dataset-manager.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initDatasetManager = initDatasetManager;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst lowdbService_1 = __webpack_require__(/*! ./db/lowdbService */ \"./src/main/db/lowdbService.ts\");\n// Get the default dataset path\nconst defaultDatasetPath = path_1.default.join(electron_1.app.getPath('userData'), 'pqc-workbench-results.json');\n// Create a settings file path for storing dataset history\nconst settingsPath = path_1.default.join(electron_1.app.getPath('userData'), 'pqc-settings.json');\n// Track the current dataset path\nlet currentDatasetPath = defaultDatasetPath;\n// Track imported datasets history\nlet datasetHistory = [];\n/**\n * Load settings from disk\n */\nfunction loadSettings() {\n    try {\n        if (fs_1.default.existsSync(settingsPath)) {\n            const settingsData = JSON.parse(fs_1.default.readFileSync(settingsPath, 'utf8'));\n            datasetHistory = settingsData.datasetHistory || [];\n            // Find the last used dataset\n            const lastUsedDataset = datasetHistory.find((d) => d.lastUsed);\n            if (lastUsedDataset) {\n                // Verify the file still exists\n                if (fs_1.default.existsSync(lastUsedDataset.path)) {\n                    currentDatasetPath = lastUsedDataset.path;\n                }\n            }\n        }\n    }\n    catch (error) {\n        console.error('Error loading settings:', error);\n        // If there's an error, we'll just use the defaults\n    }\n}\n/**\n * Save settings to disk\n */\nfunction saveSettings() {\n    try {\n        // Update the lastUsed flag\n        datasetHistory = datasetHistory.map((dataset) => ({\n            ...dataset,\n            lastUsed: dataset.path === currentDatasetPath,\n        }));\n        const settingsData = {\n            datasetHistory,\n        };\n        fs_1.default.writeFileSync(settingsPath, JSON.stringify(settingsData, null, 2));\n    }\n    catch (error) {\n        console.error('Error saving settings:', error);\n    }\n}\n/**\n * Add a dataset to history if it doesn't exist\n */\nfunction addToDatasetHistory(datasetPath) {\n    if (!datasetHistory.some((d) => d.path === datasetPath)) {\n        datasetHistory.push({\n            path: datasetPath,\n            lastUsed: datasetPath === currentDatasetPath,\n        });\n        saveSettings();\n    }\n    else {\n        // Update lastUsed flag\n        datasetHistory = datasetHistory.map((dataset) => ({\n            ...dataset,\n            lastUsed: dataset.path === currentDatasetPath,\n        }));\n        saveSettings();\n    }\n}\n/**\n * Initialize the dataset manager\n */\nfunction initDatasetManager() {\n    // Load settings when the app starts\n    loadSettings();\n    // Apply the loaded settings to the lowdbService\n    lowdbService_1.lowdbService.switchDatabase(currentDatasetPath);\n    // Handler to get the current dataset path\n    electron_1.ipcMain.handle('get-dataset-path', async () => {\n        return lowdbService_1.lowdbService.getDbPath();\n    });\n    // Handler to get the dataset history\n    electron_1.ipcMain.handle('get-dataset-history', async () => {\n        // Filter history to only include datasets that still exist\n        datasetHistory = datasetHistory.filter((dataset) => {\n            try {\n                return fs_1.default.existsSync(dataset.path);\n            }\n            catch {\n                return false;\n            }\n        });\n        saveSettings();\n        return datasetHistory;\n    });\n    // Handler to get stats about a dataset\n    electron_1.ipcMain.handle('get-dataset-stats', async (_, datasetPath) => {\n        try {\n            // First check if this is the current database path\n            if (datasetPath === lowdbService_1.lowdbService.getDbPath()) {\n                // Get stats from the current database\n                await lowdbService_1.lowdbService.ensureLoaded();\n                const runs = await lowdbService_1.lowdbService.getAllRuns();\n                const quantumResults = await lowdbService_1.lowdbService.getAllQuantumResults();\n                const pqcClassicalDetails = await lowdbService_1.lowdbService.getAllPqcClassicalDetails();\n                return {\n                    runs: runs.length || 0,\n                    quantum: quantumResults.length || 0,\n                    pqcClassical: pqcClassicalDetails.length || 0,\n                };\n            }\n            else {\n                // Otherwise, read directly from the file\n                const content = fs_1.default.readFileSync(datasetPath, 'utf8');\n                const data = JSON.parse(content);\n                return {\n                    runs: data.runs?.length || 0,\n                    quantum: data.quantumResults?.length || 0,\n                    pqcClassical: data.pqcClassicalDetails?.length || 0,\n                };\n            }\n        }\n        catch (error) {\n            console.error('Error reading dataset stats:', error);\n            return {\n                runs: 0,\n                quantum: 0,\n                pqcClassical: 0,\n            };\n        }\n    });\n    // Handler to import a dataset\n    electron_1.ipcMain.handle('import-dataset', async () => {\n        try {\n            const { canceled, filePaths } = await electron_1.dialog.showOpenDialog({\n                title: 'Import Dataset',\n                filters: [{ name: 'JSON Files', extensions: ['json'] }],\n                properties: ['openFile'],\n            });\n            if (canceled || filePaths.length === 0) {\n                return { success: false, message: 'Import cancelled' };\n            }\n            const importedPath = filePaths[0];\n            // Validate the file exists and is a valid JSON\n            if (!fs_1.default.existsSync(importedPath)) {\n                return { success: false, message: 'Selected file does not exist' };\n            }\n            try {\n                const content = fs_1.default.readFileSync(importedPath, 'utf8');\n                JSON.parse(content); // Just to validate it's proper JSON\n            }\n            catch (error) {\n                return {\n                    success: false,\n                    message: 'Selected file is not a valid JSON dataset',\n                };\n            }\n            // Switch the lowdbService to use this database\n            const success = await lowdbService_1.lowdbService.switchDatabase(importedPath);\n            if (!success) {\n                return {\n                    success: false,\n                    message: 'Failed to switch to the imported dataset',\n                };\n            }\n            // Update the current dataset path\n            currentDatasetPath = importedPath;\n            // Add to dataset history\n            addToDatasetHistory(importedPath);\n            // Get stats for the imported dataset\n            const runs = await lowdbService_1.lowdbService.getAllRuns();\n            const quantumResults = await lowdbService_1.lowdbService.getAllQuantumResults();\n            const pqcClassicalDetails = await lowdbService_1.lowdbService.getAllPqcClassicalDetails();\n            const stats = {\n                runs: runs.length || 0,\n                quantum: quantumResults.length || 0,\n                pqcClassical: pqcClassicalDetails.length || 0,\n            };\n            return {\n                success: true,\n                path: importedPath,\n                stats,\n            };\n        }\n        catch (error) {\n            console.error('Error importing dataset:', error);\n            return {\n                success: false,\n                message: 'Error importing dataset: ' + error.message,\n            };\n        }\n    });\n    // Handler to import a JSON file from a specific path (for drag and drop)\n    electron_1.ipcMain.handle('import-json-from-path', async (_, filePath) => {\n        try {\n            // Validate the file exists\n            if (!fs_1.default.existsSync(filePath)) {\n                return { success: false, message: 'File does not exist' };\n            }\n            // Validate it's a JSON file by extension\n            if (!filePath.toLowerCase().endsWith('.json')) {\n                return { success: false, message: 'File is not a JSON file' };\n            }\n            // Validate the file is a valid JSON and has the expected structure\n            try {\n                const content = fs_1.default.readFileSync(filePath, 'utf8');\n                const jsonData = JSON.parse(content);\n                // More comprehensive structure validation\n                if (!jsonData || typeof jsonData !== 'object') {\n                    return {\n                        success: false,\n                        message: 'Invalid dataset format: Not a JSON object',\n                    };\n                }\n                // Check for required dataset structure\n                // Expect runs, quantumResults, and pqcClassicalDetails to be arrays\n                if (!Array.isArray(jsonData.runs) &&\n                    !Array.isArray(jsonData.quantumResults) &&\n                    !Array.isArray(jsonData.pqcClassicalDetails)) {\n                    return {\n                        success: false,\n                        message: 'Invalid dataset format: Missing required data structures',\n                    };\n                }\n            }\n            catch (error) {\n                return {\n                    success: false,\n                    message: `Invalid JSON file: ${error.message}`,\n                };\n            }\n            // Switch the lowdbService to use this database\n            const success = await lowdbService_1.lowdbService.switchDatabase(filePath);\n            if (!success) {\n                return {\n                    success: false,\n                    message: 'Failed to use the imported dataset',\n                };\n            }\n            // Update the current dataset path\n            currentDatasetPath = filePath;\n            // Add to dataset history\n            addToDatasetHistory(filePath);\n            // Get stats for the imported dataset\n            const runs = await lowdbService_1.lowdbService.getAllRuns();\n            const quantumResults = await lowdbService_1.lowdbService.getAllQuantumResults();\n            const pqcClassicalDetails = await lowdbService_1.lowdbService.getAllPqcClassicalDetails();\n            const stats = {\n                runs: runs.length || 0,\n                quantum: quantumResults.length || 0,\n                pqcClassical: pqcClassicalDetails.length || 0,\n            };\n            return {\n                success: true,\n                path: filePath,\n                stats,\n            };\n        }\n        catch (error) {\n            console.error('Error importing JSON from path:', error);\n            return {\n                success: false,\n                message: 'Error importing dataset: ' + error.message,\n            };\n        }\n    });\n    // Handler to save a dataset\n    electron_1.ipcMain.handle('save-dataset', async () => {\n        try {\n            const { canceled, filePath } = await electron_1.dialog.showSaveDialog({\n                title: 'Save Dataset',\n                defaultPath: path_1.default.join(electron_1.app.getPath('documents'), 'dataset.json'),\n                filters: [{ name: 'JSON Files', extensions: ['json'] }],\n            });\n            if (canceled || !filePath) {\n                return { success: false, message: 'Save cancelled' };\n            }\n            // Make sure the current database is saved\n            await lowdbService_1.lowdbService.ensureLoaded();\n            // Read the current database file\n            const currentData = fs_1.default.readFileSync(lowdbService_1.lowdbService.getDbPath(), 'utf8');\n            // Write to the new location\n            fs_1.default.writeFileSync(filePath, currentData);\n            // Add to dataset history\n            addToDatasetHistory(filePath);\n            return { success: true, path: filePath };\n        }\n        catch (error) {\n            console.error('Error saving dataset:', error);\n            return {\n                success: false,\n                message: 'Error saving dataset: ' + error.message,\n            };\n        }\n    });\n    // Handler to switch to a different dataset\n    electron_1.ipcMain.handle('switch-dataset', async (_, datasetPath) => {\n        try {\n            // Validate the file exists and is a valid JSON\n            if (!fs_1.default.existsSync(datasetPath)) {\n                return { success: false, message: 'Dataset file does not exist' };\n            }\n            try {\n                const content = fs_1.default.readFileSync(datasetPath, 'utf8');\n                JSON.parse(content); // Just to validate it's proper JSON\n            }\n            catch (error) {\n                return {\n                    success: false,\n                    message: 'Selected file is not a valid JSON dataset',\n                };\n            }\n            // Switch the lowdbService to use this database\n            const success = await lowdbService_1.lowdbService.switchDatabase(datasetPath);\n            if (!success) {\n                return {\n                    success: false,\n                    message: 'Failed to switch to the selected dataset',\n                };\n            }\n            // Update the current dataset path\n            currentDatasetPath = datasetPath;\n            // Update dataset history\n            addToDatasetHistory(datasetPath);\n            // Get stats for the dataset using the lowdbService\n            const runs = await lowdbService_1.lowdbService.getAllRuns();\n            const quantumResults = await lowdbService_1.lowdbService.getAllQuantumResults();\n            const pqcClassicalDetails = await lowdbService_1.lowdbService.getAllPqcClassicalDetails();\n            const stats = {\n                runs: runs.length || 0,\n                quantum: quantumResults.length || 0,\n                pqcClassical: pqcClassicalDetails.length || 0,\n            };\n            return {\n                success: true,\n                stats,\n            };\n        }\n        catch (error) {\n            console.error('Error switching dataset:', error);\n            return {\n                success: false,\n                message: 'Error switching dataset: ' + error.message,\n            };\n        }\n    });\n    // Handler to create a new empty dataset\n    electron_1.ipcMain.handle('create-new-dataset', async () => {\n        try {\n            // Create a new dataset file path\n            const newDatasetPath = path_1.default.join(electron_1.app.getPath('temp'), `new-dataset-${Date.now()}.json`);\n            // Create a new empty database using lowdbService\n            const success = await lowdbService_1.lowdbService.createNewDatabase(newDatasetPath);\n            if (!success) {\n                return {\n                    success: false,\n                    message: 'Failed to create new dataset',\n                };\n            }\n            // Update the current dataset path\n            currentDatasetPath = newDatasetPath;\n            // Add to dataset history\n            addToDatasetHistory(newDatasetPath);\n            // Get stats for the empty dataset (should be all zeros)\n            const stats = {\n                runs: 0,\n                quantum: 0,\n                pqcClassical: 0,\n            };\n            return {\n                success: true,\n                path: newDatasetPath,\n                stats,\n            };\n        }\n        catch (error) {\n            console.error('Error creating new dataset:', error);\n            return {\n                success: false,\n                message: 'Error creating new dataset: ' + error.message,\n            };\n        }\n    });\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./src/main/dataset-manager.ts?");

/***/ }),

/***/ "./src/main/db/lowdbService.ts":
/*!*************************************!*\
  !*** ./src/main/db/lowdbService.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lowdbService = void 0;\nconst lowdb_1 = __webpack_require__(/*! lowdb */ \"./node_modules/lowdb/lib/index.js\");\nconst node_1 = __webpack_require__(/*! lowdb/node */ \"./node_modules/lowdb/lib/node.js\");\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst nanoid_1 = __webpack_require__(/*! nanoid */ \"./node_modules/nanoid/index.js\");\n// Default empty database structure\nconst defaultData = {\n    runs: [],\n    quantumResults: [],\n    pqcClassicalDetails: [],\n    articles: [],\n    rssFeeds: [],\n};\n// Create a class to encapsulate LowDB operations\nclass LowDBService {\n    constructor() {\n        this.initialized = false;\n        // Set the default dataset path\n        this.defaultDatasetPath = path.join(electron_1.app.getPath('userData'), 'pqc-workbench-results.json');\n        // Initially use the default path\n        this.dbPath = this.defaultDatasetPath;\n        // Create a new adapter with the default path\n        const adapter = new node_1.JSONFile(this.dbPath);\n        // Initialize with default data structure\n        this.db = new lowdb_1.Low(adapter, defaultData);\n    }\n    /**\n     * Get the current database path\n     */\n    getDbPath() {\n        return this.dbPath;\n    }\n    /**\n     * Switch to a different database file\n     */\n    async switchDatabase(newDbPath) {\n        try {\n            // Create a new adapter with the new path\n            const adapter = new node_1.JSONFile(newDbPath);\n            // Save the current database if it's been initialized\n            if (this.initialized) {\n                await this.db.write();\n            }\n            // Switch to the new database\n            this.db = new lowdb_1.Low(adapter, defaultData);\n            this.dbPath = newDbPath;\n            this.initialized = false;\n            // Initialize the new database\n            await this.initialize();\n            console.log(`Switched database to: ${newDbPath}`);\n            return true;\n        }\n        catch (error) {\n            console.error('Error switching database:', error);\n            return false;\n        }\n    }\n    /**\n     * Create a new empty database\n     */\n    async createNewDatabase(newDbPath) {\n        try {\n            // Create a new adapter with the new path\n            const adapter = new node_1.JSONFile(newDbPath);\n            // Create a new database with empty data\n            this.db = new lowdb_1.Low(adapter, { ...defaultData });\n            this.dbPath = newDbPath;\n            this.initialized = false;\n            // Write the empty database to disk\n            await this.db.write();\n            // Initialize the new database\n            await this.initialize();\n            console.log(`Created new database at: ${newDbPath}`);\n            return true;\n        }\n        catch (error) {\n            console.error('Error creating new database:', error);\n            return false;\n        }\n    }\n    /**\n     * Reset to the default database\n     */\n    async resetToDefaultDatabase() {\n        return await this.switchDatabase(this.defaultDatasetPath);\n    }\n    /**\n     * Initialize the database\n     */\n    async initialize() {\n        try {\n            // Read the database\n            await this.db.read();\n            // Make sure data is initialized (should already be from constructor)\n            if (!this.db.data) {\n                this.db.data = {\n                    runs: [],\n                    quantumResults: [],\n                    pqcClassicalDetails: [],\n                    articles: [],\n                    rssFeeds: [],\n                };\n            }\n            // Write the default structure if needed\n            if (!this.initialized) {\n                await this.db.write();\n                this.initialized = true;\n                console.log(`LowDB initialized successfully at ${this.dbPath}`);\n            }\n        }\n        catch (error) {\n            console.error('Error initializing LowDB:', error);\n            throw error;\n        }\n    }\n    /**\n     * Ensure the database is loaded before operations\n     */\n    async ensureLoaded() {\n        if (!this.initialized) {\n            await this.initialize();\n        }\n        else {\n            // Refresh data if needed\n            await this.db.read();\n        }\n    }\n    /**\n     * Create a new run record\n     */\n    async createRun(runType, algorithm, securityParam, iterations, notes) {\n        await this.ensureLoaded();\n        const runId = (0, nanoid_1.nanoid)();\n        const newRun = {\n            runId,\n            timestamp: new Date().toISOString(),\n            runType,\n            status: 'pending',\n            algorithm,\n            securityParam,\n            iterations,\n            notes,\n        };\n        this.db.data.runs.push(newRun);\n        await this.db.write();\n        return runId;\n    }\n    /**\n     * Update the status of a run\n     */\n    async updateRunStatus(runId, status, error) {\n        await this.ensureLoaded();\n        const runIndex = this.db.data.runs.findIndex((r) => r.runId === runId);\n        if (runIndex > -1) {\n            this.db.data.runs[runIndex].status = status;\n            if (error) {\n                this.db.data.runs[runIndex].error = error;\n            }\n            await this.db.write();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Insert quantum result data\n     */\n    async insertQuantumResult(runId, resultData) {\n        await this.ensureLoaded();\n        const resultId = (0, nanoid_1.nanoid)();\n        const newResult = {\n            resultId,\n            runId,\n            ...resultData,\n        };\n        this.db.data.quantumResults.push(newResult);\n        await this.db.write();\n        return resultId;\n    }\n    /**\n     * Insert PQC/Classical benchmark result\n     */\n    async insertPqcClassicalResult(runId, benchmarkData) {\n        await this.ensureLoaded();\n        const mainAlgorithm = benchmarkData.algorithm;\n        const iterations = benchmarkData.iterations;\n        const detailIds = [];\n        // Process each result item\n        if (benchmarkData.results && Array.isArray(benchmarkData.results)) {\n            for (const resultItem of benchmarkData.results) {\n                const detailId = (0, nanoid_1.nanoid)();\n                let variant;\n                // Special handling for AES to ensure security parameter is preserved\n                if (mainAlgorithm.toLowerCase() === 'aes' && resultItem.algorithm) {\n                    variant = resultItem.algorithm;\n                }\n                else {\n                    variant =\n                        resultItem.algorithm ||\n                            resultItem.parameter ||\n                            resultItem.key_size?.toString() ||\n                            'unknown';\n                }\n                // Create the detail record\n                const newDetail = {\n                    detailId,\n                    runId,\n                    mainAlgorithm,\n                    variant,\n                    iterations,\n                    ...resultItem,\n                };\n                this.db.data.pqcClassicalDetails.push(newDetail);\n                detailIds.push(detailId);\n            }\n        }\n        else {\n            // If there are no detailed results, create a single entry\n            const detailId = (0, nanoid_1.nanoid)();\n            const newDetail = {\n                detailId,\n                runId,\n                mainAlgorithm,\n                variant: benchmarkData.securityParam || 'unknown',\n                iterations: iterations || 0,\n                ...benchmarkData,\n            };\n            this.db.data.pqcClassicalDetails.push(newDetail);\n            detailIds.push(detailId);\n        }\n        await this.db.write();\n        return detailIds;\n    }\n    /**\n     * Get all runs\n     */\n    async getAllRuns() {\n        await this.ensureLoaded();\n        return [...(this.db.data.runs || [])];\n    }\n    /**\n     * Get runs by type\n     */\n    async getRunsByType(runType) {\n        await this.ensureLoaded();\n        return this.db.data.runs.filter((r) => r.runType === runType);\n    }\n    /**\n     * Get runs by status\n     */\n    async getRunsByStatus(status) {\n        await this.ensureLoaded();\n        return this.db.data.runs.filter((r) => r.status === status);\n    }\n    /**\n     * Get runs by algorithm\n     */\n    async getRunsByAlgorithm(algorithm) {\n        await this.ensureLoaded();\n        return this.db.data.runs.filter((r) => r.algorithm === algorithm);\n    }\n    /**\n     * Get full details of a run\n     */\n    async getFullRunDetails(runId) {\n        await this.ensureLoaded();\n        const run = this.db.data.runs.find((r) => r.runId === runId);\n        let details = [];\n        if (run) {\n            if (run.runType === 'PQC_Classical') {\n                details = this.db.data.pqcClassicalDetails.filter((d) => d.runId === runId);\n            }\n            else {\n                // Quantum result (Shor or Grover)\n                details = this.db.data.quantumResults.filter((d) => d.runId === runId);\n            }\n        }\n        return { run, details };\n    }\n    /**\n     * Get run by ID\n     */\n    async getRunById(runId) {\n        await this.ensureLoaded();\n        return this.db.data.runs.find((r) => r.runId === runId);\n    }\n    /**\n     * Get all quantum results\n     */\n    async getAllQuantumResults() {\n        await this.ensureLoaded();\n        return [...(this.db.data.quantumResults || [])];\n    }\n    /**\n     * Get quantum result by ID\n     */\n    async getQuantumResultById(resultId) {\n        await this.ensureLoaded();\n        return this.db.data.quantumResults.find((r) => r.resultId === resultId);\n    }\n    /**\n     * Get all PQC/Classical details\n     */\n    async getAllPqcClassicalDetails() {\n        await this.ensureLoaded();\n        return [...(this.db.data.pqcClassicalDetails || [])];\n    }\n    /**\n     * Get PQC/Classical details by algorithm\n     */\n    async getPqcClassicalDetailsByAlgorithm(algorithm) {\n        await this.ensureLoaded();\n        return this.db.data.pqcClassicalDetails.filter((d) => d.mainAlgorithm === algorithm);\n    }\n    /**\n     * Delete a run and its associated details\n     */\n    async deleteRun(runId) {\n        await this.ensureLoaded();\n        const initialRunsLength = this.db.data.runs.length;\n        // Remove the run\n        this.db.data.runs = this.db.data.runs.filter((r) => r.runId !== runId);\n        // Remove associated details\n        this.db.data.quantumResults = this.db.data.quantumResults.filter((r) => r.runId !== runId);\n        this.db.data.pqcClassicalDetails = this.db.data.pqcClassicalDetails.filter((d) => d.runId !== runId);\n        // Only write if something was deleted\n        if (initialRunsLength !== this.db.data.runs.length) {\n            await this.db.write();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Clear all data\n     */\n    async clearAllData() {\n        await this.ensureLoaded();\n        this.db.data = {\n            runs: [],\n            quantumResults: [],\n            pqcClassicalDetails: [],\n            articles: [],\n            rssFeeds: [],\n        };\n        await this.db.write();\n    }\n    /**\n     * Add a new article\n     */\n    async addArticle(article) {\n        await this.ensureLoaded();\n        const id = (0, nanoid_1.nanoid)();\n        // Make sure the article has all required properties\n        const newArticle = {\n            id,\n            title: article.title || 'No Title',\n            content: article.content || 'No Content',\n            date: article.date || new Date().toISOString(),\n            ...article,\n        };\n        this.db.data.articles.push(newArticle);\n        await this.db.write();\n        return id;\n    }\n    /**\n     * Update an article\n     */\n    async updateArticle(id, updates) {\n        await this.ensureLoaded();\n        const index = this.db.data.articles.findIndex((article) => article.id === id);\n        if (index === -1)\n            return false;\n        this.db.data.articles[index] = {\n            ...this.db.data.articles[index],\n            ...updates,\n        };\n        await this.db.write();\n        return true;\n    }\n    /**\n     * Get all articles\n     */\n    async getAllArticles() {\n        await this.ensureLoaded();\n        return this.db.data.articles;\n    }\n    /**\n     * Delete an article\n     */\n    async deleteArticle(id) {\n        await this.ensureLoaded();\n        const initialLength = this.db.data.articles.length;\n        this.db.data.articles = this.db.data.articles.filter((article) => article.id !== id);\n        await this.db.write();\n        return initialLength > this.db.data.articles.length;\n    }\n    /**\n     * Add a new RSS feed\n     */\n    async addRssFeed(feed) {\n        await this.ensureLoaded();\n        const id = (0, nanoid_1.nanoid)();\n        // Make sure the feed has all required properties\n        const newFeed = {\n            id,\n            url: feed.url || 'https://example.com',\n            name: feed.name || 'Default Feed',\n            ...feed,\n        };\n        this.db.data.rssFeeds.push(newFeed);\n        await this.db.write();\n        return id;\n    }\n    /**\n     * Get all RSS feeds\n     */\n    async getAllRssFeeds() {\n        await this.ensureLoaded();\n        return this.db.data.rssFeeds;\n    }\n    /**\n     * Update RSS feed last fetched timestamp\n     */\n    async updateRssFeedLastFetched(id) {\n        await this.ensureLoaded();\n        const index = this.db.data.rssFeeds.findIndex((feed) => feed.id === id);\n        if (index === -1)\n            return false;\n        this.db.data.rssFeeds[index].lastFetched = new Date().toISOString();\n        await this.db.write();\n        return true;\n    }\n}\n// Create and export a singleton instance\nexports.lowdbService = new LowDBService();\n\n\n//# sourceURL=webpack://pqcbenchgui4/./src/main/db/lowdbService.ts?");

/***/ }),

/***/ "./src/main/ipc.ts":
/*!*************************!*\
  !*** ./src/main/ipc.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setupBenchmarkIPC = setupBenchmarkIPC;\nexports.setupEncryptionIPC = setupEncryptionIPC;\nexports.setupQuantumWorkloadIPC = setupQuantumWorkloadIPC;\nexports.setupDatabaseIPC = setupDatabaseIPC;\nexports.setupJobSchedulerIPC = setupJobSchedulerIPC;\nexports.setupArticleIPC = setupArticleIPC;\nexports.setupExportIPC = setupExportIPC;\n// src/main/ipc.ts\n// Import Electron using require with type assertion\nconst electron = __webpack_require__(/*! electron */ \"electron\");\nconst { ipcMain, app, safeStorage } = electron;\nconst benchmarkManager_1 = __webpack_require__(/*! ./benchmarkManager */ \"./src/main/benchmarkManager.ts\");\nconst store_1 = __webpack_require__(/*! ./store */ \"./src/main/store/index.ts\");\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst promises_1 = __webpack_require__(/*! fs/promises */ \"fs/promises\"); // Import for checking if venv Python exists\nconst crypto = __importStar(__webpack_require__(/*! crypto */ \"crypto\")); // Import Node crypto\nconst util_1 = __webpack_require__(/*! util */ \"util\"); // Import promisify\nconst childProcess = __importStar(__webpack_require__(/*! child_process */ \"child_process\")); // Import for spawning the Python script\nconst lowdbService_1 = __webpack_require__(/*! ./db/lowdbService */ \"./src/main/db/lowdbService.ts\");\nconst JobSchedulerService_1 = __webpack_require__(/*! ./JobSchedulerService */ \"./src/main/JobSchedulerService.ts\");\nconst export_service_1 = __webpack_require__(/*! ./services/export-service */ \"./src/main/services/export-service.ts\");\n// IMPORTANT: Set up native library paths BEFORE loading any modules\n// This must happen at the top level, not inside a function\n// Load the native addons with robust error handling\n// Declare the variables at the top level\nlet kyberAddon = null;\nlet dilithiumAddon = null;\n/**\n * Calculates the effective project root directory.\n * In development, it assumes the script is running from somewhere within the project structure\n * (like dist/main) and navigates up to find the directory containing package.json.\n * In production, it uses process.resourcesPath, which points to the app's resources directory.\n */\nfunction getProjectRoot() {\n    const isDevelopment = \"development\" === 'development';\n    if (isDevelopment) {\n        // In development, __dirname is likely .../PQCBenchGUI4/dist/main\n        // We want to go up two levels to get .../PQCBenchGUI4\n        // A more robust way might be to search upwards for package.json\n        let currentDir = __dirname;\n        while (!fs.existsSync(path.join(currentDir, 'package.json')) &&\n            currentDir !== path.parse(currentDir).root) {\n            currentDir = path.dirname(currentDir);\n        }\n        if (fs.existsSync(path.join(currentDir, 'package.json'))) {\n            console.log(`[getProjectRoot] Found project root via package.json search: ${currentDir}`);\n            return currentDir;\n        }\n        else {\n            // Fallback if package.json not found (less reliable)\n            const fallbackPath = path.resolve(__dirname, '..', '..');\n            console.warn(`[getProjectRoot] Could not find package.json upwards from ${__dirname}. Falling back to ${fallbackPath}`);\n            return fallbackPath; // Adjust if your structure is different\n        }\n    }\n    else {\n        // In production, resourcesPath is the standard directory containing app assets\n        // Type assertion for process to access resourcesPath\n        const processAny = process;\n        const resourcesPath = processAny.resourcesPath || path.dirname(app.getAppPath()); // process.resourcesPath is preferred\n        console.log(`[getProjectRoot] Production mode, using resources path: ${resourcesPath}`);\n        return resourcesPath;\n    }\n}\nconst projectRoot = getProjectRoot(); // Calculate once\n// Call setupNativeLibraryPaths immediately to ensure DLL paths are set up early\nconst addonBuildDir = path.join(projectRoot, 'addons', 'build', 'Release');\nsetupNativeLibraryPaths(); // Call at the top level to ensure it runs before any require\nfunction getAddonPaths(addonName) {\n    const isDevelopment = \"development\" === 'development';\n    const pathsToSearch = [];\n    // --- Primary Addon Location ---\n    // In Dev: <projectRoot>/addons/build/Release/addon.node\n    // In Prod: <resourcesPath>/addons/build/Release/addon.node (assuming copied during packaging)\n    const primaryAddonDir = path.join(projectRoot, 'addons', 'build', 'Release');\n    const primaryAddonPath = path.join(primaryAddonDir, `${addonName}.node`);\n    pathsToSearch.push(primaryAddonPath);\n    console.log(`[getAddonPaths] Primary search path for ${addonName}: ${primaryAddonPath}`);\n    console.log(`[getAddonPaths] (Derived from projectRoot: ${projectRoot})`);\n    // --- Optional: Fallback if packaging structure differs ---\n    // if (!isDevelopment) {\n    //     // Example: If addons are directly in resources root in production\n    //     const altProdPath = path.join(projectRoot, `${addonName}.node`);\n    //     if(altProdPath !== primaryAddonPath) pathsToSearch.push(altProdPath);\n    // }\n    return pathsToSearch;\n}\nfunction setupNativeLibraryPaths() {\n    const isDevelopment = \"development\" === 'development';\n    console.log(`[setupNativeLibraryPaths] Setting up paths. isDev: ${isDevelopment}`);\n    // --- Determine Expected Paths ---\n    // Directory where addons (.node files) and copied DLLs reside\n    const addonBuildDir = path.join(projectRoot, 'addons', 'build', 'Release');\n    // Source directories of the original DLLs (within external/libs)\n    // ** IMPORTANT: Verify these paths match your OQS build output **\n    const oqsSourceBinDir = path.join(projectRoot, 'external', 'libs', 'oqs', 'install', 'bin'); // Use 'install/bin' as per copy-deps script\n    const opensslSourceBinDir = path.join(projectRoot, 'external', 'libs', 'openssl', 'openssl-3.0', 'x64', 'bin');\n    const oqsSourceLibDir = path.join(projectRoot, 'external', 'libs', 'oqs', 'install', 'lib'); // For Linux/macOS .so/.dylib\n    const opensslSourceLibDir = path.join(projectRoot, 'external', 'libs', 'openssl', 'openssl-3.0', 'x64', 'lib'); // For Linux/macOS .so/.dylib\n    console.log(`[setupNativeLibraryPaths] Addon Build Dir: ${addonBuildDir}`);\n    console.log(`[setupNativeLibraryPaths] OQS Source Bin Dir: ${oqsSourceBinDir}`);\n    console.log(`[setupNativeLibraryPaths] OpenSSL Source Bin Dir: ${opensslSourceBinDir}`);\n    // Verify the DLLs are physically present in addonBuildDir\n    const requiredDlls = ['oqs.dll', 'libcrypto-3-x64.dll'];\n    let missingDlls = false;\n    for (const dll of requiredDlls) {\n        const dllPath = path.join(addonBuildDir, dll);\n        if (fs.existsSync(dllPath)) {\n            console.log(`[setupNativeLibraryPaths] Found DLL: ${dllPath}`);\n        }\n        else {\n            console.error(`[setupNativeLibraryPaths] MISSING DLL: ${dllPath}`);\n            missingDlls = true;\n        }\n    }\n    if (missingDlls) {\n        console.warn(`[setupNativeLibraryPaths] Some required DLLs are missing from ${addonBuildDir}`);\n        console.warn('[setupNativeLibraryPaths] Running copy-deps script to ensure DLLs are present...');\n        // Try to run the copy-deps script synchronously to ensure DLLs are copied\n        try {\n            const copyDepsPath = path.join(projectRoot, 'scripts', 'copy-native-deps.js');\n            if (fs.existsSync(copyDepsPath)) {\n                const childProcess = __webpack_require__(/*! child_process */ \"child_process\");\n                childProcess.execSync(`node \"${copyDepsPath}\"`, {\n                    cwd: projectRoot,\n                    stdio: 'inherit', // show output\n                });\n                console.log('[setupNativeLibraryPaths] Successfully ran copy-deps script');\n            }\n            else {\n                console.error(`[setupNativeLibraryPaths] copy-deps script not found at ${copyDepsPath}`);\n            }\n        }\n        catch (err) {\n            console.error('[setupNativeLibraryPaths] Error running copy-deps script:', err);\n        }\n    }\n    // --- Configure Environment Variables ---\n    if (process.platform === 'win32') {\n        // On Windows, PATH is crucial for finding DLLs.\n        // Prepend the directory containing the addons AND the copied DLLs.\n        // This ensures the loader finds the adjacent DLLs first.\n        const currentPath = process.env.PATH || '';\n        // Create a new PATH with addonBuildDir at the beginning, followed by the source dirs, then the original PATH\n        // This maximizes the chance of finding the DLLs\n        const newPath = [\n            addonBuildDir, // Most important - should be found first\n            oqsSourceBinDir,\n            opensslSourceBinDir,\n            currentPath,\n        ]\n            .filter(Boolean)\n            .join(path.delimiter);\n        process.env.PATH = newPath;\n        console.log(`[setupNativeLibraryPaths] Set PATH to prioritize addon build dir.`);\n        console.log(`[setupNativeLibraryPaths] New PATH: ${process.env.PATH}`);\n        // Special case for process.dlopen on Windows\n        // Node.js v14+ has process.setDLLDirectory() but it's not commonly available\n        // As a workaround, we rely heavily on the PATH environment variable\n    }\n    else if (process.platform === 'darwin') {\n        // On macOS, DYLD_LIBRARY_PATH or rpath is used.\n        // Setting DYLD_LIBRARY_PATH: Prepend addon dir, append source lib dirs.\n        const currentDyldPath = process.env.DYLD_LIBRARY_PATH || '';\n        process.env.DYLD_LIBRARY_PATH = [\n            addonBuildDir,\n            oqsSourceLibDir,\n            opensslSourceLibDir,\n            currentDyldPath,\n        ]\n            .filter(Boolean)\n            .join(path.delimiter); // Filter avoids empty strings if vars unset\n        console.log('[setupNativeLibraryPaths] Setting DYLD_LIBRARY_PATH:', process.env.DYLD_LIBRARY_PATH);\n    }\n    else {\n        // Linux\n        // On Linux, LD_LIBRARY_PATH or rpath is used.\n        // Setting LD_LIBRARY_PATH: Prepend addon dir, append source lib dirs.\n        const currentLdPath = process.env.LD_LIBRARY_PATH || '';\n        process.env.LD_LIBRARY_PATH = [\n            addonBuildDir,\n            oqsSourceLibDir,\n            opensslSourceLibDir,\n            currentLdPath,\n        ]\n            .filter(Boolean)\n            .join(path.delimiter); // Filter avoids empty strings\n        console.log('[setupNativeLibraryPaths] Setting LD_LIBRARY_PATH:', process.env.LD_LIBRARY_PATH);\n    }\n    console.log('[setupNativeLibraryPaths] Path setup complete.');\n}\nfunction loadNativeAddon(addonName) {\n    const possiblePaths = getAddonPaths(addonName);\n    let foundPath = '';\n    let lastError = null;\n    console.log(`Searching for ${addonName} in:`, possiblePaths);\n    // Verify the native addon (.node file) exists\n    const addonExistsAtPath = (path) => {\n        if (fs.existsSync(path)) {\n            console.log(`[loadNativeAddon] Found addon file: ${path}`);\n            return true;\n        }\n        console.log(`[loadNativeAddon] Addon file NOT found: ${path}`);\n        return false;\n    };\n    for (const addonPath of possiblePaths) {\n        try {\n            // 1. Check if the .node file itself exists\n            if (addonExistsAtPath(addonPath)) {\n                console.log(`[loadNativeAddon] Attempting to load module from '${addonPath}'...`);\n                // 2. Use process.dlopen to load the addon directly instead of require\n                // This bypasses webpack's module system which can interfere with native modules\n                let addon;\n                try {\n                    // First try with require - this might work for some configurations\n                    addon = __webpack_require__(\"./src/main sync recursive\")(addonPath);\n                    console.log(`[loadNativeAddon] Successfully loaded with require: ${addonPath}`);\n                }\n                catch (err) {\n                    // Cast the unknown error to any to access message property safely\n                    const reqError = err;\n                    console.log(`[loadNativeAddon] require() failed, trying alternate methods (${reqError.message})`);\n                    // If require fails, we'll try alternate approaches\n                    // This needs to be carefully handled since we're using internal APIs\n                    try {\n                        // Attempt to use node-bindings if available\n                        try {\n                            // Try node-bindings package if available (dynamically)\n                            const bindings = __webpack_require__(/*! bindings */ \"./node_modules/bindings/bindings.js\");\n                            addon = bindings(path.basename(addonPath, '.node'));\n                            console.log(`[loadNativeAddon] Successfully loaded using bindings: ${addonPath}`);\n                        }\n                        catch (bindingError) {\n                            // Bindings not available, try direct process.dlopen\n                            // as a last resort (but this is risky)\n                            // Note: process.dlopen is not in the TypeScript defs but is available at runtime\n                            // We need to use any type to bypass TypeScript's type checking\n                            const proc = process;\n                            if (typeof proc.dlopen === 'function') {\n                                let moduleObject = { exports: {} };\n                                proc.dlopen(moduleObject, addonPath);\n                                addon = moduleObject.exports;\n                                console.log(`[loadNativeAddon] Successfully loaded using process.dlopen: ${addonPath}`);\n                            }\n                            else {\n                                throw new Error('No available method to load native addon');\n                            }\n                        }\n                    }\n                    catch (dlopenError) {\n                        // All attempts failed\n                        throw new Error(`All module loading approaches failed: ${dlopenError.message}`);\n                    }\n                }\n                // 3. Validate exported functions\n                let isValid = false;\n                if (addonName === 'kyber_node_addon') {\n                    isValid =\n                        typeof addon.generateKeypair === 'function' &&\n                            typeof addon.encapsulate === 'function' &&\n                            typeof addon.decapsulate === 'function';\n                }\n                else if (addonName === 'dilithium_node_addon') {\n                    isValid =\n                        typeof addon.generateKeypair === 'function' &&\n                            typeof addon.sign === 'function' &&\n                            typeof addon.verify === 'function';\n                }\n                if (isValid) {\n                    console.log(`[loadNativeAddon] Successfully validated ${addonName} from ${addonPath}`);\n                    return addon; // Success!\n                }\n                else {\n                    foundPath = addonPath; // Mark as found but invalid\n                    const msg = `Loaded ${addonName} from ${addonPath}, but validation failed (missing expected functions). Exports: ${Object.keys(addon || {})}`;\n                    console.warn(`[loadNativeAddon] ${msg}`);\n                    lastError = new Error(msg);\n                    // Don't continue searching if validation fails - the loaded module is wrong.\n                    break;\n                }\n            }\n        }\n        catch (error) {\n            // This catch block handles errors during the `require(addonPath)` call\n            // Most likely \"Cannot find module\" or dependency loading errors (DLL not found)\n            console.warn(`[loadNativeAddon] Failed to load ${addonName} from ${addonPath}: ${error.message}`);\n            console.warn(`[loadNativeAddon] Error code: ${error.code}, Error details: `, error);\n            if (error.code === 'MODULE_NOT_FOUND') {\n                console.warn(`[loadNativeAddon] Hint: If the file exists, this often means a required DLL dependency (like oqs.dll or libcrypto) was not found by the OS loader.`);\n                console.warn(`[loadNativeAddon] Verify DLLs are present in ${path.dirname(addonPath)} and PATH/LD_LIBRARY_PATH/DYLD_LIBRARY_PATH includes necessary directories.`);\n                // On Windows, let's check for the presence of our DLLs again\n                if (process.platform === 'win32') {\n                    const addonDir = path.dirname(addonPath);\n                    const dllsToCheck = ['oqs.dll', 'libcrypto-3-x64.dll'];\n                    console.warn('[loadNativeAddon] Checking for DLLs in addon directory...');\n                    for (const dll of dllsToCheck) {\n                        const dllPath = path.join(addonDir, dll);\n                        console.warn(`[loadNativeAddon] ${dll} exists: ${fs.existsSync(dllPath)}`);\n                    }\n                }\n            }\n            lastError = error;\n            // If require fails for one path, continue searching other potential paths\n            if (fs.existsSync(addonPath)) {\n                foundPath = addonPath; // Mark as found but failed to load\n            }\n        }\n    }\n    // If loop completes without returning an addon\n    if (foundPath) {\n        // If we found the file but loading/validation failed\n        console.error(`[loadNativeAddon] Found ${addonName} at ${foundPath} but failed to load or validate it. Last error: ${lastError?.message}`);\n    }\n    else {\n        // If the file wasn't found in any searched path\n        console.error(`[loadNativeAddon] Failed to find ${addonName} addon in any of the searched locations: ${possiblePaths.join(', ')}`);\n        if (lastError) {\n            console.error('[loadNativeAddon] Last error during load attempts:', lastError);\n        }\n    }\n    return null; // Return null if not found or loaded correctly\n}\n// --- Initialize Addons Once on Startup ---\n// IMPORTANT: Path setup must happen before we try to load the native addons!\n// Initialize DLL paths first, at the top level\n// setupNativeLibraryPaths(); // Already called at the top level\n// Try to load the addons - use the already declared variables\ntry {\n    console.log('[IPC Init] Attempting to load Kyber encryption module...');\n    kyberAddon = loadNativeAddon('kyber_node_addon');\n    if (kyberAddon) {\n        console.log('[IPC Init] Kyber encryption module loaded successfully.');\n        // console.log('Available Kyber functions:', Object.keys(kyberAddon)); // Optional verbose\n    }\n    else {\n        console.error('[IPC Init] Could not load Kyber encryption module.');\n    }\n    console.log('[IPC Init] Attempting to load Dilithium signature module...');\n    dilithiumAddon = loadNativeAddon('dilithium_node_addon');\n    if (dilithiumAddon) {\n        console.log('[IPC Init] Dilithium signature module loaded successfully.');\n        // console.log('Available Dilithium functions:', Object.keys(dilithiumAddon)); // Optional verbose\n    }\n    else {\n        console.error('[IPC Init] Could not load Dilithium signature module.');\n    }\n}\ncatch (error) {\n    console.error('[IPC Init] Fatal error during addon initialization:', error);\n    // Consider exiting or disabling features if addons are critical\n}\n// ==========================================================================\n// IPC Handlers (No changes needed below this line from previous version)\n// ==========================================================================\nfunction setupBenchmarkIPC() {\n    // No changes needed here\n    ipcMain.handle('run-benchmark', async (event, params) => {\n        try {\n            // Set up progress reporting\n            benchmarkManager_1.benchmarkManager.onProgress((progressData) => {\n                // Send progress updates to renderer\n                event.sender.send('benchmark-progress', progressData);\n            });\n            const result = await benchmarkManager_1.benchmarkManager.runBenchmark(params);\n            // Save the benchmark result to the store\n            const savedResult = store_1.benchmarkStore.saveBenchmarkResult(result);\n            return savedResult;\n        }\n        catch (error) {\n            // We'll still save failed benchmarks but mark them as failed\n            if (error &&\n                typeof error === 'object' &&\n                error.id &&\n                error.status === 'failed') {\n                return store_1.benchmarkStore.saveBenchmarkResult(error);\n            }\n            // Log the error before potentially saving\n            console.error('Error during benchmark run:', error);\n            // Rethrow or return a structured error for the renderer\n            throw new Error(`Benchmark failed: ${error?.message || 'Unknown error'}`);\n        }\n    });\n    ipcMain.handle('stop-benchmark', async (_event, benchmarkId) => {\n        return benchmarkManager_1.benchmarkManager.stopBenchmark(benchmarkId);\n    });\n    // New IPC handlers for benchmark data operations\n    ipcMain.handle('get-all-benchmarks', async () => {\n        return store_1.benchmarkStore.getAllBenchmarkResults();\n    });\n    ipcMain.handle('get-benchmarks-by-algorithm', async (_event, algorithm) => {\n        return store_1.benchmarkStore.getBenchmarksByAlgorithm(algorithm);\n    });\n    ipcMain.handle('get-benchmarks-by-security-param', async (_event, securityParam) => {\n        return store_1.benchmarkStore.getBenchmarksBySecurityParam(securityParam);\n    });\n    ipcMain.handle('get-benchmarks-by-algorithm-and-param', async (_event, algorithm, securityParam) => {\n        return store_1.benchmarkStore.getBenchmarksByAlgorithmAndParam(algorithm, securityParam);\n    });\n    ipcMain.handle('get-benchmarks-by-date-range', async (_event, startDate, endDate) => {\n        return store_1.benchmarkStore.getBenchmarksByDateRange(new Date(startDate), new Date(endDate));\n    });\n    ipcMain.handle('get-benchmarks-by-status', async (_event, status) => {\n        return store_1.benchmarkStore.getBenchmarksByStatus(status);\n    });\n    ipcMain.handle('get-benchmark-by-id', async (_event, id) => {\n        return store_1.benchmarkStore.getBenchmarkById(id);\n    });\n    ipcMain.handle('delete-benchmark', async (_event, id) => {\n        return store_1.benchmarkStore.deleteBenchmark(id);\n    });\n    ipcMain.handle('clear-all- benchmarks', async () => {\n        store_1.benchmarkStore.clearAllBenchmarks();\n        return true;\n    });\n}\n// Setup Encryption/Signature IPC\nfunction setupEncryptionIPC() {\n    console.log('[IPC] Setting up Encryption/Signature IPC handlers...');\n    // --- Node Crypto Helpers ---\n    const hkdfAsync = (0, util_1.promisify)(crypto.hkdf);\n    ipcMain.handle('node-crypto-hkdf', async (_event, ikmBase64, length, saltBase64, infoString) => {\n        console.log(`[IPC] Handling 'node-crypto-hkdf'`);\n        try {\n            const ikm = Buffer.from(ikmBase64, 'base64');\n            const salt = saltBase64\n                ? Buffer.from(saltBase64, 'base64')\n                : Buffer.alloc(0); // Use empty buffer if no salt provided\n            // Ensure info is a buffer, even if empty\n            const info = infoString\n                ? Buffer.from(infoString, 'utf8')\n                : Buffer.alloc(0);\n            // Use the promisified version with await\n            const derivedKeyArrayBuffer = await hkdfAsync('sha256', ikm, salt, info, length);\n            const derivedKeyBuffer = Buffer.from(derivedKeyArrayBuffer);\n            return derivedKeyBuffer.toString('base64');\n        }\n        catch (error) {\n            console.error('[IPC Error] node-crypto-hkdf:', error);\n            throw new Error(`HKDF operation failed: ${error.message}`);\n        }\n    });\n    const randomBytesAsync = (0, util_1.promisify)(crypto.randomBytes);\n    ipcMain.handle('node-crypto-get-random-bytes', async (_event, length) => {\n        console.log(`[IPC] Handling 'node-crypto-get-random-bytes'`);\n        try {\n            const buf = await randomBytesAsync(length);\n            return buf.toString('base64');\n        }\n        catch (error) {\n            console.error('[IPC Error] node-crypto-get-random-bytes:', error);\n            throw new Error(`randomBytes operation failed: ${error.message}`);\n        }\n    });\n    // --- Kyber Handlers ---\n    const createKyberErrorHandler = (channel) => {\n        return async (_event, ...args) => {\n            console.error(`[IPC Error] Attempted to call ${channel} but Kyber addon is not loaded.`);\n            throw new Error(`Kyber addon is not loaded. Cannot execute ${channel}.`);\n        };\n    };\n    ipcMain.handle('kyber-generate-keypair', kyberAddon\n        ? async (_event, securityLevel) => {\n            console.log(`[IPC] Handling 'kyber-generate-keypair' (${securityLevel})`);\n            try {\n                if (!kyberAddon)\n                    throw new Error('Kyber addon became unavailable.'); // Re-check before use\n                const result = kyberAddon.generateKeypair(securityLevel);\n                if (!result || !result.publicKey || !result.secretKey) {\n                    throw new Error('Kyber generateKeypair addon returned invalid result');\n                }\n                return {\n                    publicKey: result.publicKey.toString('base64'),\n                    secretKey: result.secretKey.toString('base64'),\n                    publicKeySize: result.publicKey.length,\n                    secretKeySize: result.secretKey.length,\n                };\n            }\n            catch (error) {\n                console.error('[IPC Error] kyber-generate-keypair:', error);\n                throw new Error(`Kyber generateKeypair failed: ${error.message || 'Unknown native error'}`);\n            }\n        }\n        : createKyberErrorHandler('kyber-generate-keypair'));\n    ipcMain.handle('kyber-encapsulate', kyberAddon\n        ? async (_event, securityLevel, publicKeyBase64) => {\n            console.log(`[IPC] Handling 'kyber-encapsulate' (${securityLevel})`);\n            try {\n                if (!kyberAddon)\n                    throw new Error('Kyber addon became unavailable.');\n                const publicKey = Buffer.from(publicKeyBase64, 'base64');\n                const result = kyberAddon.encapsulate(securityLevel, publicKey);\n                if (!result || !result.kemCiphertext || !result.sharedSecret) {\n                    throw new Error('Kyber encapsulate addon returned invalid result');\n                }\n                return {\n                    kemCiphertext: result.kemCiphertext.toString('base64'),\n                    sharedSecret: result.sharedSecret.toString('base64'),\n                };\n            }\n            catch (error) {\n                console.error('[IPC Error] kyber-encapsulate:', error);\n                throw new Error(`Kyber encapsulate failed: ${error.message || 'Unknown native error'}`);\n            }\n        }\n        : createKyberErrorHandler('kyber-encapsulate'));\n    ipcMain.handle('kyber-decapsulate', kyberAddon\n        ? async (_event, securityLevel, secretKeyBase64, kemCiphertextBase64) => {\n            console.log(`[IPC] Handling 'kyber-decapsulate' (${securityLevel})`);\n            try {\n                if (!kyberAddon)\n                    throw new Error('Kyber addon became unavailable.');\n                const secretKey = Buffer.from(secretKeyBase64, 'base64');\n                const kemCiphertext = Buffer.from(kemCiphertextBase64, 'base64');\n                const sharedSecret = kyberAddon.decapsulate(securityLevel, secretKey, kemCiphertext);\n                if (!sharedSecret || !Buffer.isBuffer(sharedSecret)) {\n                    console.error('Kyber decapsulate did not return a Buffer. Type:', typeof sharedSecret);\n                    throw new Error('Kyber decapsulate addon returned invalid result (expected Buffer)');\n                }\n                return sharedSecret.toString('base64');\n            }\n            catch (error) {\n                console.error('[IPC Error] kyber-decapsulate:', error);\n                throw new Error(`Kyber decapsulate failed: ${error.message || 'Unknown native error'}`);\n            }\n        }\n        : createKyberErrorHandler('kyber-decapsulate'));\n    ipcMain.removeHandler('kyber-encrypt');\n    ipcMain.removeHandler('kyber-decrypt');\n    // --- Dilithium Handlers ---\n    const createDilithiumErrorHandler = (channel) => {\n        return async (_event, ...args) => {\n            console.error(`[IPC Error] Attempted to call ${channel} but Dilithium addon is not loaded.`);\n            throw new Error(`Dilithium addon is not loaded. Cannot execute ${channel}.`);\n        };\n    };\n    ipcMain.handle('dilithium-generate-keypair', dilithiumAddon\n        ? async (_event, securityLevel) => {\n            console.log(`[IPC] Handling 'dilithium-generate-keypair' (${securityLevel})`);\n            try {\n                if (!dilithiumAddon)\n                    throw new Error('Dilithium addon became unavailable.');\n                const result = dilithiumAddon.generateKeypair(securityLevel);\n                if (!result || !result.publicKey || !result.secretKey) {\n                    throw new Error('Dilithium generateKeypair addon returned invalid result');\n                }\n                return {\n                    publicKey: result.publicKey.toString('base64'),\n                    secretKey: result.secretKey.toString('base64'),\n                    publicKeySize: result.publicKey.length,\n                    secretKeySize: result.secretKey.length,\n                };\n            }\n            catch (error) {\n                console.error('[IPC Error] dilithium-generate-keypair:', error);\n                throw new Error(`Dilithium generateKeypair failed: ${error.message || 'Unknown native error'}`);\n            }\n        }\n        : createDilithiumErrorHandler('dilithium-generate-keypair'));\n    ipcMain.handle('dilithium-sign', dilithiumAddon\n        ? async (_event, securityLevel, secretKeyBase64, messageInput) => {\n            console.log(`[IPC] Handling 'dilithium-sign' (${securityLevel})`);\n            try {\n                if (!dilithiumAddon)\n                    throw new Error('Dilithium addon became unavailable.');\n                const secretKey = Buffer.from(secretKeyBase64, 'base64');\n                const messageBuffer = Buffer.isBuffer(messageInput)\n                    ? messageInput\n                    : Buffer.from(messageInput, 'utf8');\n                const signature = dilithiumAddon.sign(securityLevel, secretKey, messageBuffer);\n                if (!signature || !Buffer.isBuffer(signature)) {\n                    throw new Error('Dilithium sign addon returned invalid result (expected Buffer)');\n                }\n                return {\n                    signature: signature.toString('base64'),\n                    signatureSize: signature.length,\n                };\n            }\n            catch (error) {\n                console.error(`[IPC Error] dilithium-sign:`, error);\n                throw new Error(`Dilithium sign failed: ${error.message || 'Unknown native error'}`);\n            }\n        }\n        : createDilithiumErrorHandler('dilithium-sign'));\n    ipcMain.handle('dilithium-verify', dilithiumAddon\n        ? async (_event, securityLevel, publicKeyBase64, messageInput, signatureBase64) => {\n            console.log(`[IPC] Handling 'dilithium-verify' (${securityLevel})`);\n            try {\n                if (!dilithiumAddon)\n                    throw new Error('Dilithium addon became unavailable.');\n                const publicKey = Buffer.from(publicKeyBase64, 'base64');\n                const signature = Buffer.from(signatureBase64, 'base64');\n                const messageBuffer = Buffer.isBuffer(messageInput)\n                    ? messageInput\n                    : Buffer.from(messageInput, 'utf8');\n                const isValid = dilithiumAddon.verify(securityLevel, publicKey, messageBuffer, signature);\n                if (typeof isValid !== 'boolean') {\n                    console.error('Verify addon returned non-boolean type:', typeof isValid);\n                    throw new Error('Dilithium verify addon returned invalid result type (expected boolean)');\n                }\n                return { isValid: isValid };\n            }\n            catch (error) {\n                console.error(`[IPC Error] dilithium-verify:`, error);\n                throw new Error(`Dilithium verify failed: ${error.message || 'Unknown native error'}`);\n            }\n        }\n        : createDilithiumErrorHandler('dilithium-verify'));\n    console.log('[IPC] Encryption/Signature IPC handlers registration complete.');\n}\n// --- Quantum Workload Functions ---\n/**\n * Runs the Shor's algorithm quantum workload using the Python script\n * @param {string} apiToken - IBM Quantum API token (required for hardware runs)\n * @param {number} shots - Number of shots to run\n * @param {boolean} runOnHardware - Whether to run on real quantum hardware\n * @param {string} plotTheme - Plot theme (light or dark)\n * @returns {Promise<Object>} Result object with status, output data, logs, and plot path\n */\nasync function runQuantumWorkload(apiToken, shots, runOnHardware, plotTheme) {\n    console.log('[Quantum Workload] Starting quantum workload execution...');\n    // Generate unique filenames for outputs using timestamp and random ID\n    const timestamp = Date.now();\n    const randomId = Math.random().toString(36).substring(2, 10);\n    const userDataPath = app.getPath('userData');\n    const outputPath = path.join(userDataPath, 'quantum_outputs');\n    // Ensure the output directory exists\n    if (!fs.existsSync(outputPath)) {\n        fs.mkdirSync(outputPath, { recursive: true });\n    }\n    // Generate paths for output files\n    const plotFilePath = path.join(outputPath, `plot_${timestamp}_${randomId}.png`);\n    const jsonFilePath = path.join(outputPath, `result_${timestamp}_${randomId}.json`);\n    // Determine the path to the Python script\n    const isDevelopment = \"development\" === 'development';\n    const projectRoot = getProjectRoot();\n    // In development, use the script in the project directory\n    // In production, the script should be in resources/quantum\n    let scriptPath = '';\n    if (isDevelopment) {\n        scriptPath = path.join(projectRoot, 'quantum', 'shor_n15.py');\n    }\n    else {\n        // In production, resources folder contains our extra resources\n        const processAny = process;\n        scriptPath = path.join(processAny.resourcesPath, 'quantum', 'shor_n15.py');\n    }\n    // Verify the script exists\n    if (!fs.existsSync(scriptPath)) {\n        console.error(`[Quantum Workload] ERROR: Script not found at ${scriptPath}`);\n        return {\n            status: 'error',\n            error: `Python script not found at ${scriptPath}`,\n            logs: [`ERROR: Python script not found at ${scriptPath}`],\n        };\n    }\n    // Determine the Python executable path from virtual environment\n    let pythonExecutable = 'python'; // Default fallback\n    const venvPythonPath = path.join(projectRoot, '.venv', 'Scripts', 'python.exe'); // Windows path\n    // Check if the venv Python executable exists and is accessible\n    try {\n        await (0, promises_1.access)(venvPythonPath);\n        pythonExecutable = venvPythonPath;\n        console.log(`[Quantum Workload] Using Python from virtual environment: ${pythonExecutable}`);\n    }\n    catch (err) {\n        console.warn(`[Quantum Workload] Virtual environment Python not found at ${venvPythonPath}, falling back to system Python`);\n    }\n    // Build command arguments\n    const args = [\n        '--api_token',\n        apiToken,\n        '--shots',\n        shots.toString(),\n        '--plot_file',\n        plotFilePath,\n        '--plot_theme',\n        plotTheme,\n        '--output_json',\n        jsonFilePath,\n    ];\n    // Add run_on_hardware flag if true\n    if (runOnHardware) {\n        args.push('--run_on_hardware');\n    }\n    // Store logs\n    const logs = [];\n    console.log(`[Quantum Workload] Executing Python script: ${pythonExecutable} ${scriptPath} ${args.join(' ')}`);\n    // Execute the script using spawn to capture real-time output\n    return new Promise((resolve, reject) => {\n        // When using the full path to python.exe, we need to pass the script path as the first argument\n        const pythonProcess = childProcess.spawn(pythonExecutable, [\n            scriptPath,\n            ...args,\n        ]);\n        // Capture stderr output for logs (script logs to stderr)\n        pythonProcess.stderr.on('data', (data) => {\n            const logLines = data.toString().split('\\n').filter(Boolean);\n            logs.push(...logLines);\n            console.log(`[Quantum Workload Log] ${data.toString().trim()}`);\n        });\n        // Handle process completion\n        pythonProcess.on('close', (code) => {\n            console.log(`[Quantum Workload] Python process exited with code ${code}`);\n            // Check if output JSON exists and is readable\n            if (fs.existsSync(jsonFilePath)) {\n                try {\n                    const resultData = JSON.parse(fs.readFileSync(jsonFilePath, 'utf8'));\n                    // Check if plot file exists\n                    const plotExists = fs.existsSync(plotFilePath);\n                    if (!plotExists) {\n                        logs.push('WARNING: Plot file was not generated.');\n                    }\n                    // Return comprehensive result object\n                    resolve({\n                        status: code === 0 ? 'success' : 'error',\n                        exitCode: code,\n                        data: resultData,\n                        logs: logs,\n                        plotFilePath: plotExists ? plotFilePath : null,\n                        jsonFilePath: jsonFilePath,\n                    });\n                }\n                catch (err) {\n                    console.error('[Quantum Workload] Error parsing result JSON:', err);\n                    reject({\n                        status: 'error',\n                        error: 'Failed to parse result JSON',\n                        logs: logs,\n                        exitCode: code,\n                    });\n                }\n            }\n            else {\n                console.error('[Quantum Workload] Result JSON file not found');\n                reject({\n                    status: 'error',\n                    error: 'Result file not generated',\n                    logs: logs,\n                    exitCode: code,\n                });\n            }\n        });\n        // Handle process errors\n        pythonProcess.on('error', (err) => {\n            console.error('[Quantum Workload] Failed to start Python process:', err);\n            reject({\n                status: 'error',\n                error: `Failed to start Python process: ${err.message}`,\n                logs: logs,\n            });\n        });\n    });\n}\n/**\n * Runs Grover's search algorithm quantum workload using the Python script\n * @param {string} apiToken - IBM Quantum API token (required for hardware runs)\n * @param {string} markedStates - Comma-separated list of binary strings to mark\n * @param {number} shots - Number of shots to run\n * @param {boolean} runOnHardware - Whether to run on real quantum hardware\n * @param {string} plotTheme - Plot theme (light or dark)\n * @returns {Promise<Object>} Result object with status, output data, logs, and plot path\n */\nasync function runGroverSearch(apiToken, markedStates, shots, runOnHardware, plotTheme) {\n    console.log('[Grover Search] Starting Grover search execution...');\n    // Generate unique filenames for outputs using timestamp and random ID\n    const timestamp = Date.now();\n    const randomId = Math.random().toString(36).substring(2, 10);\n    const userDataPath = app.getPath('userData');\n    const outputPath = path.join(userDataPath, 'quantum_outputs');\n    // Ensure the output directory exists\n    if (!fs.existsSync(outputPath)) {\n        fs.mkdirSync(outputPath, { recursive: true });\n    }\n    // Generate paths for output files\n    const plotFilePath = path.join(outputPath, `grover_plot_${timestamp}_${randomId}.png`);\n    const jsonFilePath = path.join(outputPath, `grover_result_${timestamp}_${randomId}.json`);\n    // Determine the path to the Python script\n    const isDevelopment = \"development\" === 'development';\n    const projectRoot = getProjectRoot();\n    // In development, use the script in the project directory\n    // In production, the script should be in resources/quantum\n    let scriptPath = '';\n    if (isDevelopment) {\n        scriptPath = path.join(projectRoot, 'quantum', 'grover_search.py');\n    }\n    else {\n        // In production, resources folder contains our extra resources\n        const processAny = process;\n        scriptPath = path.join(processAny.resourcesPath, 'quantum', 'grover_search.py');\n    }\n    // Verify the script exists\n    if (!fs.existsSync(scriptPath)) {\n        console.error(`[Grover Search] ERROR: Script not found at ${scriptPath}`);\n        return {\n            status: 'error',\n            error: `Python script not found at ${scriptPath}`,\n            logs: [`ERROR: Python script not found at ${scriptPath}`],\n        };\n    }\n    // Determine the Python executable path from virtual environment\n    let pythonExecutable = 'python'; // Default fallback\n    const venvPythonPath = path.join(projectRoot, '.venv', 'Scripts', 'python.exe'); // Windows path\n    // Check if the venv Python executable exists and is accessible\n    try {\n        await (0, promises_1.access)(venvPythonPath);\n        pythonExecutable = venvPythonPath;\n        console.log(`[Grover Search] Using Python from virtual environment: ${pythonExecutable}`);\n    }\n    catch (err) {\n        console.warn(`[Grover Search] Virtual environment Python not found at ${venvPythonPath}, falling back to system Python`);\n    }\n    // Build command arguments\n    const args = [\n        '--api_token',\n        apiToken,\n        '--marked_states',\n        markedStates,\n        '--shots',\n        shots.toString(),\n        '--plot_file',\n        plotFilePath,\n        '--plot_theme',\n        plotTheme,\n        '--output_json',\n        jsonFilePath,\n    ];\n    // Add run_on_hardware flag if true\n    if (runOnHardware) {\n        args.push('--run_on_hardware');\n    }\n    // Store logs\n    const logs = [];\n    console.log(`[Grover Search] Executing Python script: ${pythonExecutable} ${scriptPath} ${args.join(' ')}`);\n    // Execute the script using spawn to capture real-time output\n    return new Promise((resolve, reject) => {\n        // When using the full path to python.exe, we need to pass the script path as the first argument\n        const pythonProcess = childProcess.spawn(pythonExecutable, [\n            scriptPath,\n            ...args,\n        ]);\n        // Capture stderr output for logs (script logs to stderr)\n        pythonProcess.stderr.on('data', (data) => {\n            const logLines = data.toString().split('\\n').filter(Boolean);\n            logs.push(...logLines);\n            console.log(`[Grover Search Log] ${data.toString().trim()}`);\n        });\n        // Handle process completion\n        pythonProcess.on('close', (code) => {\n            console.log(`[Grover Search] Python process exited with code ${code}`);\n            // Check if output JSON exists and is readable\n            if (fs.existsSync(jsonFilePath)) {\n                try {\n                    const resultData = JSON.parse(fs.readFileSync(jsonFilePath, 'utf8'));\n                    // Check if plot file exists\n                    const plotExists = fs.existsSync(plotFilePath);\n                    if (!plotExists) {\n                        logs.push('WARNING: Plot file was not generated.');\n                    }\n                    // Return comprehensive result object\n                    resolve({\n                        status: code === 0 ? 'success' : 'error',\n                        exitCode: code,\n                        data: resultData,\n                        logs: logs,\n                        plotFilePath: plotExists ? plotFilePath : null,\n                        jsonFilePath: jsonFilePath,\n                    });\n                }\n                catch (err) {\n                    console.error('[Grover Search] Error parsing result JSON:', err);\n                    reject({\n                        status: 'error',\n                        error: 'Failed to parse result JSON',\n                        logs: logs,\n                        exitCode: code,\n                    });\n                }\n            }\n            else {\n                console.error('[Grover Search] Result JSON file not found');\n                reject({\n                    status: 'error',\n                    error: 'Result file not generated',\n                    logs: logs,\n                    exitCode: code,\n                });\n            }\n        });\n        // Handle process errors\n        pythonProcess.on('error', (err) => {\n            console.error('[Grover Search] Failed to start Python process:', err);\n            reject({\n                status: 'error',\n                error: `Failed to start Python process: ${err.message}`,\n                logs: logs,\n            });\n        });\n    });\n}\n// --- Quantum API Token Storage ---\n/**\n * Saves the IBM Quantum API token securely using Electron's safeStorage\n * @param apiToken The API token to encrypt and save\n * @returns Success status\n */\nasync function saveQuantumApiToken(apiToken) {\n    try {\n        // First, encrypt the token using Electron's safeStorage\n        const encryptedToken = safeStorage.encryptString(apiToken);\n        // Save to a file in the app's user data directory\n        const tokenFilePath = path.join(app.getPath('userData'), 'quantum_api_token.enc');\n        fs.writeFileSync(tokenFilePath, encryptedToken);\n        console.log('[Quantum API] Token saved successfully');\n        return true;\n    }\n    catch (error) {\n        console.error('[Quantum API] Error saving token:', error);\n        return false;\n    }\n}\n/**\n * Loads the encrypted IBM Quantum API token from storage and decrypts it\n * @returns The decrypted API token, or null if not found or error\n */\nasync function loadQuantumApiToken() {\n    try {\n        const tokenFilePath = path.join(app.getPath('userData'), 'quantum_api_token.enc');\n        // Check if token file exists\n        if (!fs.existsSync(tokenFilePath)) {\n            console.log('[Quantum API] No saved token found');\n            return null;\n        }\n        // Read and decrypt the token\n        const encryptedToken = fs.readFileSync(tokenFilePath);\n        const decryptedToken = safeStorage.decryptString(encryptedToken);\n        console.log('[Quantum API] Token loaded successfully');\n        return decryptedToken;\n    }\n    catch (error) {\n        console.error('[Quantum API] Error loading token:', error);\n        return null;\n    }\n}\n/**\n * Deletes the stored API token\n * @returns Success status\n */\nasync function deleteQuantumApiToken() {\n    try {\n        const tokenFilePath = path.join(app.getPath('userData'), 'quantum_api_token.enc');\n        // Check if token file exists\n        if (!fs.existsSync(tokenFilePath)) {\n            console.log('[Quantum API] No token to delete');\n            return true;\n        }\n        // Delete the token file\n        fs.unlinkSync(tokenFilePath);\n        console.log('[Quantum API] Token deleted successfully');\n        return true;\n    }\n    catch (error) {\n        console.error('[Quantum API] Error deleting token:', error);\n        return false;\n    }\n}\n// Setup Quantum Workload IPC Handlers\nfunction setupQuantumWorkloadIPC() {\n    console.log('[IPC] Setting up Quantum Workload IPC handlers...');\n    // Add handlers for API token storage\n    ipcMain.handle('save-quantum-api-token', async (_event, apiToken) => {\n        return saveQuantumApiToken(apiToken);\n    });\n    ipcMain.handle('load-quantum-api-token', async () => {\n        return loadQuantumApiToken();\n    });\n    ipcMain.handle('delete-quantum-api-token', async () => {\n        return deleteQuantumApiToken();\n    });\n    // Existing handlers\n    ipcMain.handle('run-quantum-workload', async (_event, apiToken, shots, runOnHardware, plotTheme) => {\n        try {\n            // Create a run record in the database\n            const runId = await lowdbService_1.lowdbService.createRun('Quantum_Shor', 'Shor', 'N=15', // Fixed for now\n            shots);\n            // Update run status to running\n            await lowdbService_1.lowdbService.updateRunStatus(runId, 'running');\n            // Run the quantum workload\n            const result = await runQuantumWorkload(apiToken, shots, runOnHardware, plotTheme);\n            if (result.status === 'success') {\n                // Store the result in the database\n                await lowdbService_1.lowdbService.insertQuantumResult(runId, result);\n                // Update run status to completed\n                await lowdbService_1.lowdbService.updateRunStatus(runId, 'completed');\n            }\n            else {\n                // Update run status to failed\n                await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', result.error || 'Unknown error during quantum workload execution');\n            }\n            return result;\n        }\n        catch (error) {\n            console.error('[IPC Error] run-quantum-workload:', error);\n            return {\n                status: 'error',\n                error: error.message || 'Unknown error during quantum workload execution',\n                logs: error.logs || [],\n            };\n        }\n    });\n    // Add handler for Grover's search algorithm\n    ipcMain.handle('run-grover-search', async (_event, apiToken, markedStates, shots, runOnHardware, plotTheme) => {\n        try {\n            // Create a run record in the database\n            const runId = await lowdbService_1.lowdbService.createRun('Quantum_Grover', 'Grover', markedStates, // Use markedStates as securityParam\n            shots);\n            // Update run status to running\n            await lowdbService_1.lowdbService.updateRunStatus(runId, 'running');\n            // Run the Grover search\n            const result = await runGroverSearch(apiToken, markedStates, shots, runOnHardware, plotTheme);\n            if (result.status === 'success') {\n                // Store the result in the database\n                await lowdbService_1.lowdbService.insertQuantumResult(runId, result);\n                // Update run status to completed\n                await lowdbService_1.lowdbService.updateRunStatus(runId, 'completed');\n            }\n            else {\n                // Update run status to failed\n                await lowdbService_1.lowdbService.updateRunStatus(runId, 'failed', result.error || 'Unknown error during Grover search execution');\n            }\n            return result;\n        }\n        catch (error) {\n            console.error('[IPC Error] run-grover-search:', error);\n            return {\n                status: 'error',\n                error: error.message || 'Unknown error during Grover search execution',\n                logs: error.logs || [],\n            };\n        }\n    });\n    ipcMain.handle('get-quantum-plot', async (_event, plotFilePath) => {\n        try {\n            if (fs.existsSync(plotFilePath)) {\n                // Read the file as a base64 string\n                const plotData = fs.readFileSync(plotFilePath);\n                return {\n                    status: 'success',\n                    plotBase64: plotData.toString('base64'),\n                };\n            }\n            else {\n                return {\n                    status: 'error',\n                    error: 'Plot file not found',\n                };\n            }\n        }\n        catch (error) {\n            console.error('[IPC Error] get-quantum-plot:', error);\n            return {\n                status: 'error',\n                error: error.message || 'Unknown error when retrieving plot',\n            };\n        }\n    });\n    console.log('[IPC] Quantum Workload IPC handlers registration complete.');\n}\n// Setup Database IPC handlers\nfunction setupDatabaseIPC() {\n    console.log('[IPC] Setting up Database IPC handlers...');\n    // Import the lowdbService here to avoid circular dependencies\n    const { lowdbService } = __webpack_require__(/*! ./db/lowdbService */ \"./src/main/db/lowdbService.ts\");\n    // Run-related handlers\n    ipcMain.handle('db:create-run', async (_event, runType, algorithm, securityParam, iterations, notes) => {\n        try {\n            return await lowdbService.createRun(runType, algorithm, securityParam, iterations, notes);\n        }\n        catch (error) {\n            console.error('[IPC Error] db:create-run:', error);\n            throw new Error(`Failed to create run: ${error.message}`);\n        }\n    });\n    ipcMain.handle('db:update-run-status', async (_event, runId, status, error) => {\n        try {\n            return await lowdbService.updateRunStatus(runId, status, error);\n        }\n        catch (error) {\n            console.error('[IPC Error] db:update-run-status:', error);\n            throw new Error(`Failed to update run status: ${error.message}`);\n        }\n    });\n    ipcMain.handle('db:get-all-runs', async () => {\n        try {\n            return await lowdbService.getAllRuns();\n        }\n        catch (error) {\n            console.error('[IPC Error] db:get-all-runs:', error);\n            throw new Error(`Failed to get all runs: ${error.message}`);\n        }\n    });\n    ipcMain.handle('db:get-runs-by-type', async (_event, runType) => {\n        try {\n            return await lowdbService.getRunsByType(runType);\n        }\n        catch (error) {\n            console.error('[IPC Error] db:get-runs-by-type:', error);\n            throw new Error(`Failed to get runs by type: ${error.message}`);\n        }\n    });\n    ipcMain.handle('db:get-runs-by-status', async (_event, status) => {\n        try {\n            return await lowdbService.getRunsByStatus(status);\n        }\n        catch (error) {\n            console.error('[IPC Error] db:get-runs-by-status:', error);\n            throw new Error(`Failed to get runs by status: ${error.message}`);\n        }\n    });\n    ipcMain.handle('db:get-runs-by-algorithm', async (_event, algorithm) => {\n        try {\n            return await lowdbService.getRunsByAlgorithm(algorithm);\n        }\n        catch (error) {\n            console.error('[IPC Error] db:get-runs-by-algorithm:', error);\n            throw new Error(`Failed to get runs by algorithm: ${error.message}`);\n        }\n    });\n    ipcMain.handle('db:get-run-details', async (_event, runId) => {\n        try {\n            return await lowdbService.getFullRunDetails(runId);\n        }\n        catch (error) {\n            console.error('[IPC Error] db:get-run-details:', error);\n            throw new Error(`Failed to get run details: ${error.message}`);\n        }\n    });\n    // Result-related handlers\n    ipcMain.handle('db:insert-quantum-result', async (_event, runId, resultData) => {\n        try {\n            return await lowdbService.insertQuantumResult(runId, resultData);\n        }\n        catch (error) {\n            console.error('[IPC Error] db:insert-quantum-result:', error);\n            throw new Error(`Failed to insert quantum result: ${error.message}`);\n        }\n    });\n    ipcMain.handle('db:insert-pqc-classical-result', async (_event, runId, benchmarkData) => {\n        try {\n            return await lowdbService.insertPqcClassicalResult(runId, benchmarkData);\n        }\n        catch (error) {\n            console.error('[IPC Error] db:insert-pqc-classical-result:', error);\n            throw new Error(`Failed to insert PQC/Classical result: ${error.message}`);\n        }\n    });\n    ipcMain.handle('db:get-all-quantum-results', async () => {\n        try {\n            return await lowdbService.getAllQuantumResults();\n        }\n        catch (error) {\n            console.error('[IPC Error] db:get-all-quantum-results:', error);\n            throw new Error(`Failed to get all quantum results: ${error.message}`);\n        }\n    });\n    ipcMain.handle('db:get-all-pqc-classical-details', async () => {\n        try {\n            return await lowdbService.getAllPqcClassicalDetails();\n        }\n        catch (error) {\n            console.error('[IPC Error] db:get-all-pqc-classical-details:', error);\n            throw new Error(`Failed to get all PQC/Classical details: ${error.message}`);\n        }\n    });\n    ipcMain.handle('db:get-pqc-classical-by-algorithm', async (_event, algorithm) => {\n        try {\n            return await lowdbService.getPqcClassicalDetailsByAlgorithm(algorithm);\n        }\n        catch (error) {\n            console.error('[IPC Error] db:get-pqc-classical-by-algorithm:', error);\n            throw new Error(`Failed to get PQC/Classical details by algorithm: ${error.message}`);\n        }\n    });\n    // Delete operations\n    ipcMain.handle('db:delete-run', async (_event, runId) => {\n        try {\n            return await lowdbService.deleteRun(runId);\n        }\n        catch (error) {\n            console.error('[IPC Error] db:delete-run:', error);\n            throw new Error(`Failed to delete run: ${error.message}`);\n        }\n    });\n    ipcMain.handle('db:clear-all-data', async () => {\n        try {\n            await lowdbService.clearAllData();\n            return true;\n        }\n        catch (error) {\n            console.error('[IPC Error] db:clear-all-data:', error);\n            throw new Error(`Failed to clear all data: ${error.message}`);\n        }\n    });\n    console.log('[IPC] Database IPC handlers registration complete.');\n}\n/**\n * Sets up Job Scheduler IPC handlers\n */\nfunction setupJobSchedulerIPC() {\n    console.log('[IPC] Setting up Job Scheduler IPC handlers...');\n    // Add handlers for job scheduling\n    ipcMain.handle('schedule-job', async (_event, jobDefinition) => {\n        try {\n            return JobSchedulerService_1.jobSchedulerService.addJob(jobDefinition);\n        }\n        catch (error) {\n            console.error('[IPC Error] schedule-job:', error);\n            return {\n                status: 'error',\n                error: error.message || 'Unknown error during job scheduling',\n            };\n        }\n    });\n    ipcMain.handle('get-job-queue', async () => {\n        try {\n            return JobSchedulerService_1.jobSchedulerService.getQueueState();\n        }\n        catch (error) {\n            console.error('[IPC Error] get-job-queue:', error);\n            return {\n                status: 'error',\n                error: error.message || 'Unknown error getting job queue state',\n            };\n        }\n    });\n    ipcMain.handle('cancel-job', async (_event, jobId) => {\n        try {\n            return JobSchedulerService_1.jobSchedulerService.cancelJob(jobId);\n        }\n        catch (error) {\n            console.error('[IPC Error] cancel-job:', error);\n            return {\n                status: 'error',\n                error: error.message || 'Unknown error cancelling job',\n            };\n        }\n    });\n    ipcMain.handle('remove-job', async (_event, jobId) => {\n        try {\n            return JobSchedulerService_1.jobSchedulerService.removeJob(jobId);\n        }\n        catch (error) {\n            console.error('[IPC Error] remove-job:', error);\n            return {\n                status: 'error',\n                error: error.message || 'Unknown error removing job',\n            };\n        }\n    });\n    console.log('[IPC] Job Scheduler IPC handlers registration complete.');\n}\n// Setup Article and RSS IPC - FEATURE REMOVED\n// This function is kept as a stub for backward compatibility but with its implementation removed\nfunction setupArticleIPC() {\n    console.log('[IPC] Article and RSS feature has been removed.');\n    // Implementation removed as this feature is no longer supported\n}\n// Add this function to setup export-related IPC handlers\nfunction setupExportIPC() {\n    console.log('[IPC] Setting up Export IPC handlers...');\n    // Handler for exporting dataset\n    ipcMain.handle('export-dataset', async (_event, options) => {\n        try {\n            return await export_service_1.exportService.exportData(options);\n        }\n        catch (error) {\n            console.error('[IPC Error] export-dataset:', error);\n            return {\n                success: false,\n                message: error.message || 'Unknown error during export',\n            };\n        }\n    });\n    // Handler to get all runs\n    ipcMain.handle('get-all-runs', async () => {\n        try {\n            return await lowdbService_1.lowdbService.getAllRuns();\n        }\n        catch (error) {\n            console.error('[IPC Error] get-all-runs:', error);\n            return [];\n        }\n    });\n    // Handler to get all PQC/Classical details\n    ipcMain.handle('get-all-pqc-classical-details', async () => {\n        try {\n            return await lowdbService_1.lowdbService.getAllPqcClassicalDetails();\n        }\n        catch (error) {\n            console.error('[IPC Error] get-all-pqc-classical-details:', error);\n            return [];\n        }\n    });\n    // Handler to get all quantum results\n    ipcMain.handle('get-all-quantum-results', async () => {\n        try {\n            return await lowdbService_1.lowdbService.getAllQuantumResults();\n        }\n        catch (error) {\n            console.error('[IPC Error] get-all-quantum-results:', error);\n            return [];\n        }\n    });\n    console.log('[IPC] Export IPC handlers registration complete.');\n}\n\n\n//# sourceURL=webpack://pqcbenchgui4/./src/main/ipc.ts?");

/***/ }),

/***/ "./src/main/main.ts":
/*!**************************!*\
  !*** ./src/main/main.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// Import Electron using require with type assertion\nconst electron = __webpack_require__(/*! electron */ \"electron\");\nconst { app, BrowserWindow } = electron;\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst ipc_1 = __webpack_require__(/*! ./ipc */ \"./src/main/ipc.ts\");\nconst lowdbService_1 = __webpack_require__(/*! ./db/lowdbService */ \"./src/main/db/lowdbService.ts\");\nconst JobSchedulerService_1 = __webpack_require__(/*! ./JobSchedulerService */ \"./src/main/JobSchedulerService.ts\");\nconst dataset_manager_1 = __webpack_require__(/*! ./dataset-manager */ \"./src/main/dataset-manager.ts\");\nlet mainWindow = null;\n// Enable live reload in development mode\n/* Commenting out electron-reload for now to fix errors\nif (process.env.NODE_ENV === 'development') {\n    try {\n        require('electron-reload')(__dirname, {\n            electron: path.join(__dirname, '..', 'node_modules', '.bin', 'electron'),\n            hardResetMethod: 'exit',\n        });\n        console.log('Electron reload enabled for development');\n    } catch (err) {\n        console.error('Failed to setup electron-reload:', err);\n    }\n}\n*/\nfunction createWindow() {\n    mainWindow = new BrowserWindow({\n        width: 1200,\n        height: 800,\n        webPreferences: {\n            nodeIntegration: true,\n            contextIsolation: true,\n            preload: path.join(__dirname, 'preload.js'),\n        },\n        // Modern UI touches\n        titleBarStyle: 'hidden',\n        titleBarOverlay: {\n            color: '#1f2937',\n            symbolColor: '#f9fafb',\n            height: 40,\n        },\n        backgroundColor: '#111827', // Dark background color\n    });\n    // Load the index.html file from the dist directory\n    const indexPath = path.join(__dirname, 'index.html');\n    console.log('Loading index.html from:', indexPath);\n    mainWindow.loadFile(indexPath); // Remove hash: 'home' since React Router handles routing\n    // Open DevTools in development\n    if (true) {\n        mainWindow.webContents.openDevTools();\n    }\n    // Set the mainWindow reference in the JobSchedulerService\n    JobSchedulerService_1.jobSchedulerService.setMainWindow(mainWindow);\n    // Handle window close event\n    mainWindow.on('closed', () => {\n        mainWindow = null;\n    });\n    return mainWindow;\n}\n// Initialize the LowDB database\nasync function initializeDatabase() {\n    try {\n        await lowdbService_1.lowdbService.initialize();\n        console.log('Database initialized successfully');\n    }\n    catch (error) {\n        console.error('Error initializing database:', error);\n    }\n}\n// This method will be called when Electron has finished initialization\napp.whenReady().then(async () => {\n    // Initialize the database first\n    await initializeDatabase();\n    createWindow();\n    (0, ipc_1.setupBenchmarkIPC)();\n    (0, ipc_1.setupEncryptionIPC)(); // Set up both Kyber encryption and Dilithium signature IPC handlers\n    (0, ipc_1.setupQuantumWorkloadIPC)(); // Set up Quantum Workload IPC handlers\n    (0, ipc_1.setupDatabaseIPC)(); // Set up Database IPC handlers\n    (0, ipc_1.setupJobSchedulerIPC)(); // Set up Job Scheduler IPC handlers\n    (0, ipc_1.setupExportIPC)(); // Set up Export functionality IPC handlers\n    (0, dataset_manager_1.initDatasetManager)(); // Initialize dataset manager\n    app.on('activate', () => {\n        // On macOS, re-create a window when the dock icon is clicked and no other windows are open\n        if (BrowserWindow.getAllWindows().length === 0) {\n            createWindow();\n        }\n    });\n});\n// Quit when all windows are closed, except on macOS\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') {\n        app.quit();\n    }\n});\n// Stop the scheduler when app is about to quit\napp.on('before-quit', () => {\n    console.log('Application is about to quit, stopping job scheduler');\n    JobSchedulerService_1.jobSchedulerService.stopScheduleChecker();\n});\n\n\n//# sourceURL=webpack://pqcbenchgui4/./src/main/main.ts?");

/***/ }),

/***/ "./src/main/services/export-service.ts":
/*!*********************************************!*\
  !*** ./src/main/services/export-service.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.exportService = void 0;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst csv = __importStar(__webpack_require__(/*! fast-csv */ \"./node_modules/fast-csv/build/src/index.js\"));\nclass ExportService {\n    /**\n     * Export database content to a file\n     */\n    async exportData(options) {\n        try {\n            // Let the user select where to save the file\n            const { filePath, canceled } = await electron_1.dialog.showSaveDialog({\n                title: `Export Data as ${options.format.toUpperCase()}`,\n                defaultPath: path.join(electron_1.app.getPath('documents'), `${options.filename}.${options.format}`),\n                filters: this.getFileFilters(options.format),\n            });\n            if (canceled || !filePath) {\n                return { success: false, message: 'Export cancelled' };\n            }\n            // Export based on the selected format\n            switch (options.format) {\n                case 'json':\n                    await this.exportAsJson(filePath, options.data);\n                    break;\n                case 'csv':\n                    await this.exportAsCsv(filePath, options.data);\n                    break;\n                case 'pdf':\n                    await this.exportAsPdf(filePath, options.data);\n                    break;\n                default:\n                    return { success: false, message: 'Unsupported export format' };\n            }\n            return { success: true, path: filePath };\n        }\n        catch (error) {\n            console.error('Export error:', error);\n            return {\n                success: false,\n                message: error instanceof Error ? error.message : 'Unknown export error',\n            };\n        }\n    }\n    /**\n     * Get file filters for the save dialog based on format\n     */\n    getFileFilters(format) {\n        switch (format) {\n            case 'json':\n                return [{ name: 'JSON files', extensions: ['json'] }];\n            case 'csv':\n                return [{ name: 'CSV files', extensions: ['csv'] }];\n            case 'pdf':\n                return [{ name: 'PDF files', extensions: ['pdf'] }];\n            default:\n                return [{ name: 'All Files', extensions: ['*'] }];\n        }\n    }\n    /**\n     * Export data as JSON\n     */\n    async exportAsJson(filePath, data) {\n        // Format the JSON with indentation for readability\n        const jsonString = JSON.stringify(data, null, 2);\n        fs.writeFileSync(filePath, jsonString, 'utf8');\n    }\n    /**\n     * Export data as CSV\n     * This handles the complexity of converting nested JSON to CSV format\n     */\n    async exportAsCsv(filePath, data) {\n        // Create separate CSV files for different data types if needed\n        const baseDir = path.dirname(filePath);\n        const baseFileName = path.basename(filePath, '.csv');\n        // For simplicity, let's focus on exporting the runs first\n        // We could split into multiple files for more complex data\n        let csvData = [];\n        // Process runs data\n        if (data.runs && data.runs.length > 0) {\n            csvData = data.runs.map((run) => this.flattenObject(run));\n        }\n        // If there's PQC or Quantum data, we might want to handle that separately\n        // based on the app's specific requirements\n        // Write the CSV file\n        const writeStream = fs.createWriteStream(filePath);\n        const csvStream = csv.format({ headers: true });\n        csvStream.pipe(writeStream);\n        csvData.forEach((row) => csvStream.write(row));\n        csvStream.end();\n        // Return a promise that resolves when the file is written\n        return new Promise((resolve, reject) => {\n            writeStream.on('finish', resolve);\n            writeStream.on('error', reject);\n        });\n    }\n    /**\n     * Export data as PDF\n     * This requires a PDF generation library, which would need to be installed\n     */\n    async exportAsPdf(filePath, data) {\n        // For now, use JSON export as a fallback since PDF generation\n        // requires additional dependencies like pdfkit or jspdf\n        const jsonString = JSON.stringify(data, null, 2);\n        // In a real implementation, we would use a PDF library to create\n        // a well-formatted PDF document with tables, etc.\n        // For this demo, we'll create a simple text file with a PDF extension\n        fs.writeFileSync(filePath, `PQC Benchmark Data Export\\n\\n` +\n            `Export Date: ${new Date().toLocaleString()}\\n\\n` +\n            `Data (JSON format):\\n${jsonString}`, 'utf8');\n        // In a production app, you would replace this with proper PDF generation\n        console.log('Note: PDF export is using a simple text format. Install a PDF library for better formatting.');\n    }\n    /**\n     * Helper function to flatten nested objects for CSV export\n     */\n    flattenObject(obj, prefix = '') {\n        const result = {};\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                const value = obj[key];\n                const newKey = prefix ? `${prefix}_${key}` : key;\n                if (typeof value === 'object' &&\n                    value !== null &&\n                    !Array.isArray(value)) {\n                    // Recursively flatten nested objects\n                    Object.assign(result, this.flattenObject(value, newKey));\n                }\n                else if (Array.isArray(value)) {\n                    // Handle arrays - convert to string for CSV\n                    result[newKey] = JSON.stringify(value);\n                }\n                else {\n                    // Regular values\n                    result[newKey] = value;\n                }\n            }\n        }\n        return result;\n    }\n}\n// Create and export a singleton instance\nexports.exportService = new ExportService();\n\n\n//# sourceURL=webpack://pqcbenchgui4/./src/main/services/export-service.ts?");

/***/ }),

/***/ "./src/main/store/benchmark-store.ts":
/*!*******************************************!*\
  !*** ./src/main/store/benchmark-store.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BenchmarkStore = void 0;\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/cjs/index.js\");\nclass BenchmarkStore {\n    constructor() {\n        // Store data in the app's user data directory\n        this.storePath = path_1.default.join(electron_1.app.getPath('userData'), 'benchmark-data.json');\n        this.data = { benchmarks: [] };\n        this.loadData();\n    }\n    /**\n     * Load benchmark data from the JSON file\n     */\n    loadData() {\n        try {\n            if (fs_1.default.existsSync(this.storePath)) {\n                const fileContent = fs_1.default.readFileSync(this.storePath, 'utf-8');\n                this.data = JSON.parse(fileContent);\n            }\n            else {\n                // Initialize with empty data and create the file\n                this.saveData();\n            }\n        }\n        catch (error) {\n            console.error('Error loading benchmark data:', error);\n            // Initialize with empty data if there's an error\n            this.data = { benchmarks: [] };\n        }\n    }\n    /**\n     * Save the current data to the JSON file\n     */\n    saveData() {\n        try {\n            fs_1.default.writeFileSync(this.storePath, JSON.stringify(this.data, null, 2), 'utf-8');\n        }\n        catch (error) {\n            console.error('Error saving benchmark data:', error);\n        }\n    }\n    /**\n     * Save a new benchmark result\n     */\n    saveBenchmarkResult(result) {\n        const benchmarkWithId = {\n            ...result,\n            id: (0, uuid_1.v4)(),\n        };\n        this.data.benchmarks.push(benchmarkWithId);\n        this.saveData();\n        return benchmarkWithId;\n    }\n    /**\n     * Get all benchmark results\n     */\n    getAllBenchmarkResults() {\n        return [...this.data.benchmarks];\n    }\n    /**\n     * Get benchmark results filtered by algorithm\n     */\n    getBenchmarksByAlgorithm(algorithm) {\n        return this.data.benchmarks.filter((benchmark) => benchmark.algorithm.toLowerCase() === algorithm.toLowerCase());\n    }\n    /**\n     * Get benchmark results filtered by security parameter\n     */\n    getBenchmarksBySecurityParam(securityParam) {\n        return this.data.benchmarks.filter((benchmark) => benchmark.securityParam === securityParam);\n    }\n    /**\n     * Get benchmark results filtered by algorithm and security parameter\n     */\n    getBenchmarksByAlgorithmAndParam(algorithm, securityParam) {\n        return this.data.benchmarks.filter((benchmark) => benchmark.algorithm.toLowerCase() === algorithm.toLowerCase() &&\n            benchmark.securityParam === securityParam);\n    }\n    /**\n     * Get benchmarks within a date range\n     */\n    getBenchmarksByDateRange(startDate, endDate) {\n        return this.data.benchmarks.filter((benchmark) => {\n            const benchmarkDate = new Date(benchmark.timestamp);\n            return benchmarkDate >= startDate && benchmarkDate <= endDate;\n        });\n    }\n    /**\n     * Get benchmarks by completion status\n     */\n    getBenchmarksByStatus(status) {\n        return this.data.benchmarks.filter((benchmark) => benchmark.status === status);\n    }\n    /**\n     * Delete a benchmark by ID\n     */\n    deleteBenchmark(id) {\n        const initialLength = this.data.benchmarks.length;\n        this.data.benchmarks = this.data.benchmarks.filter((benchmark) => benchmark.id !== id);\n        if (initialLength !== this.data.benchmarks.length) {\n            this.saveData();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Clear all benchmarks\n     */\n    clearAllBenchmarks() {\n        this.data.benchmarks = [];\n        this.saveData();\n    }\n    /**\n     * Get benchmark by ID\n     */\n    getBenchmarkById(id) {\n        return this.data.benchmarks.find((benchmark) => benchmark.id === id);\n    }\n    /**\n     * Custom query function for more complex filtering\n     */\n    queryBenchmarks(filterFn) {\n        return this.data.benchmarks.filter(filterFn);\n    }\n}\nexports.BenchmarkStore = BenchmarkStore;\n\n\n//# sourceURL=webpack://pqcbenchgui4/./src/main/store/benchmark-store.ts?");

/***/ }),

/***/ "./src/main/store/index.ts":
/*!*********************************!*\
  !*** ./src/main/store/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BenchmarkStore = exports.benchmarkStore = void 0;\nconst benchmark_store_1 = __webpack_require__(/*! ./benchmark-store */ \"./src/main/store/benchmark-store.ts\");\nObject.defineProperty(exports, \"BenchmarkStore\", ({ enumerable: true, get: function () { return benchmark_store_1.BenchmarkStore; } }));\n// Create a singleton instance of the BenchmarkStore\nexports.benchmarkStore = new benchmark_store_1.BenchmarkStore();\n\n\n//# sourceURL=webpack://pqcbenchgui4/./src/main/store/index.ts?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "electron":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("electron");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "fs/promises":
/*!******************************!*\
  !*** external "fs/promises" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "node:fs/promises":
/*!***********************************!*\
  !*** external "node:fs/promises" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs/promises");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ "node:url":
/*!***************************!*\
  !*** external "node:url" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:url");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main/main.ts");
/******/ 	
/******/ })()
;